<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>sztejkat.abstractfmt - core implementation</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=UTF-8">
</head>
<body>
		This chapter is about different 
		means of implementing event/signal and indicators.
		
		<h1>Signal</h1>
		A primary means which are necessary to handle signals in stream
		is to provide an ability to indiate that signal do happen.
		<p>
		The specification requires that:
		<p>
		<i>
		(...)
		This is requied that a mechanism used for storig signals must be designed in such way,
		that there must be a possibility to	iterate through the stream from signal to signal 
		without the need of understanding anything of a stream content between signals.(...)
		</i>
		<br><small>
		See <a href="../package-summary.html">package description.</a>.</small>
		<p>
		Due to this requirement we must be able to cleary say where the signal is
		<u>regardless from which position in stream we do start looking for a signal</u>.
		<p>
		We have two possiblities:
		<ul>
			<li>escape sequence;</li>
			<li>data chunks.</li>
		</ul>
		
		<h2 id="escaped">Escape sequence</h2>
		Escape sequence is a sequence of raw data (chars or bytes) which absolutely under
		no condition can appear in stream elsewhere except at the signal.
		<p>
		A good example of escape sequences are XML tags.
		
		<h2>Data chunks</h2>
		Data chunks are fixed blocks of which size is given at the beginning of a block
		and about which we know, that the signal may appear only at the header of a data chunk.
		
		<h2>Pros and cons</h2>
		
		<table border="1">
		<tr><td></td><td>Escape sequences</td><td>Chunks</td></tr>
		<tr><td>size</td>
		    <td>
			- escapes present in stream data must be escaped
			so the stream size may be enlarged and will varry depending
			on data carried in stream. For an example an XML file
			which will carry in its body "&lt;&lt;&lt;&lt;&lt;....&lt;"
			string will be tripple size than a file which is carying
			the "aaaaa.....a" body of the same number of characters.
			</td>
			<td>
			+ having few classes of chunks we may select compact
			headers so that overhead is low
			</td>
		</tr>
		<tr><td>robustness</td>
			<td> + even if decoder will "get lost" in stream the unique 
			character of escape sequence allows easy synchronisation on
			the next signal
			</td>
			<td> - if for some reason decoder is lost the chunk size information
			will be incorrect and data which are to be interpreted as next chunk header
			will be wrong
			</td>
		</tr>
		<tr><td>scanning</td>
			<td> - stream must be processed char-by-char or byte-by-byte to find 
			signals, so skipping remaning content of an event do require reading it,
			altough without understanding
			</td>
			<td> + this is enough to read chunk header and skip, ie. using low level
			file i/o to next chunk to find a possible signal.
			</td>
		</tr>
		</table>
		
		
		
		<h2>Low level stream operations</h2>
		<i>Note: See <a href="../package-summary.html">package description</a> for
		more formal approach.</i>
		<p>
		Regardless of what approach we do select we may divide stream into blocks:
		<pre>
			begin-signal-indication
			signal-name
			<i>primitive data...</i>
		</pre>
		and 
		<pre>
			end-signal
			<i>primitive data...</i>
		</pre>
		or, if we like optimization:
		<pre>
			end-begin-signal
			signal-name
			<i>primitive data...</i>
		</pre>
		Signal indication may be an escape or a chunk header. 
		
		<h3>Signal names</h3>
		Signal name may	be direct name:
		<pre>
				direct-indicator
				signal-name-data
		</pre>
		where <code>signal-name-data</code> is an implementation specific form
		of signal name.
		<p>
		Since we clearly said that all Java characters are allowed
		then this is clear that any CR-LF or NULL-TERM methods are out of question.
		<p>
		Also we noticed in <a href="security.html">notes about security</a> that
		we need to limit name length.
		<p>
		Due to that it will be reasonable to write the size of name directly and then
		the content of it. But it is a format implementation specific.
		
		<h3>Compact names</h3>
		Since files will be used in 90% of cases to store known data signal names
		will be used to indicate known, formally specified elements. This means
		that the number of different names will be limited and that some of them
		will appear very frequently.
		<p>
		For that it is best to have an ability to use <i>compact names</i>
		or <i>names registry</i>.
		<p>
		When name is written for a first time following sequence can be used:
		<pre>
				register-indicator				
				signal-name-data
		</pre>
		The <code>register-indicator</code> may directly carry a number assigned to
		the <code>signal-name-data</code> or this number may be deduced a'priori from
		the order of appearance of those indicators. For an example first indicator
		means "name index 0" second "name index 1" and so on. This will help to keep
		file compact.
		<p>
		On the other hand when the same name is used for a second and next time
		following sequence can be used:
		<pre>
				register-use
				signal-name-index
		</pre>
		and directly recall the name "by the index". The reading end of a stream
		may transparently transform the index to a name in a string from since
		it will remember all <code>register-indicator</code> data seen before.
		<p>
		This is the rationale behind <a href="../ISignalWriteFormat.html#BEGIN">ISignalWriteFormat.begin(String,boolean)</a>
		second argument, which allows users to clearly indicate that some signals should not be optimized
		by name registry, because they are used infrequently. The good example of infrequent signals are those
		used in file headers.
		
		
		<h1>Type indicators</h1>
		The <a href="../IDescribedSignalReadFormat.html">IDescribedSignalReadFormat</a>
		declares 16 codes which are to be returned to indicate certain primitive data.
		<p>
		Reader should notice that those codes will be used practically everywhere and will
		surround practically every data.
		<p>
		This is wise then to have for them as compact indicators as possible.
		
</body>
</html>
