<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>sztejkat.abstractfmt - core implementation</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=UTF-8">
</head>
<body>
		This chapter is about means of implementing event/signal formats.
		
		<h1>Signal</h1>
		A primary means which are necessary to handle signals in stream
		is to provide an ability to indiate that signal do happen.
		<p>
		The specification requires that:
		<p>
		<i>
		(...)
		This is requied that a mechanism used for storig signals must be designed in such way,
		that there must be a possibility to	iterate through the stream from signal to signal 
		without the need of understanding anything of a stream content between signals.(...)
		</i>
		<br><small>
		See <a href="../package.html">package description.</a>.</small>
		<p>
		Due to this requirement we must be able to cleary say where the signal is
		<u>regardless from which position in stream we do start looking for a signal.</u>.
		<p>
		We have two possiblities:
		<ul>
			<li>escape sequence;</li>
			<li>data chunks;</li>
		</ul>
		
		<h2>Escape sequence</h2>
		Escape sequence is a sequence of raw data (chars or bytes) which absolutely under
		no condition can appear in stream elsewhere except at the signal.
		<p>
		A good example of escape conditions are XML tags.
		
		<h2>Data chunks</h2>
		Data chunks are fixed blocks of which size is given at the beginning of a block
		and about which we know, that the signal may appear only at the header of a data chunk.
		
		<h2>Pros and cons</h2>
		
		<table border="1">
		<tr><td></td><td>Escape sequences</td><td>Chunks</td></tr>
		<tr><td>size</td>
		    <td>
			- escapes present in stream data must be escaped
			so the stream size may be enlarged and will varry depending
			on data carried in stream
			</td>
			<td>
			+ having few classes of chunks we may select compact
			headers so that overhead is low
			</td>
		</tr>
		<tr><td>robustness</td>
			<td> + even if decoder will "get lost" in stream the unique 
			character of escape sequence allows easy synchronisation on
			the next signal
			</td>
			<td> - if for some reason decoder is lost the chunk size information
			will be incorrect and data which are to be interpreted as next chunk header
			will be wrong
			</td>
		</tr>
		<tr><td>scanning</td>
			<td> - stream must be processed primitive-by-primitive to find 
			signals, so skipping remaning content of an event do require reading it,
			altough without understanding
			</td>
			<td> + this is enough to read chunk header and skip, ie. using low level
			file i/o to next chunk to find a possible signal.
			</td>
		</tr>
		</table>
		
		<h2>Low level stream operations</h2>
		
		Regardless of what approach we do select we may divide to blocks:
		<pre>
			begin-signal-indication
			signal-name
			<i>primitive data...</i>
		</pre>
		and 
		<pre>
			end-signal
			<i>primitive data...</i>
		</pre>
		or, if we like optimization:
		<pre>
			end-begin-signal
			signal-name
			<i>primitive data...</i>
		</pre>
		Signal indication may be an escape or a chunk header. 
		
		<h3>Signal names</h3>
		Signal name may	be direct name:
		<pre>
				direct-indicator
				signal-name-data
		</pre>
		where <code>signal-name-data</code> is an implementation specific form
		of signal name.
		<p>
		Since we clearly said that all Java characters are allowed
		then this is clear that any CR-LF or NULL-TERM methods are out of question.
		<p>
		Also we notices in <a href="security.html">notes about security</a> that
		we need to limit name length.
		<p>
		Due to that it will be reasonable to write the size of name directly and then
		the content of it. But it is a format implementation specific.
		
		<h3>Compact names</h3>
		Since formats will be used in 90% of cases to store known data signal names
		will be used to indicate known, formally specified elements. This means
		that the number of different names will be limited and that some of them
		will appear very frequently.
		<p>
		For that it is best to have an ability to use <i>compact names</i>
		or <i>names registry</i>.
		<p>
		When name is written for a first time following sequence can be used:
		<pre>
				register-indicator				
				signal-name-data
		</pre>
		The <code>register-indicator</code> may directly carry a number assigned to
		the <code>signal-name-data</code> or this number may be deduces a'priori from
		the order of appearance of those indicators. For an example first indicator
		means "name index 0" second "name index 1" and so on. With that it can
		be compact.
		<p>
		On the other hand when the same name is used for a second and next times
		following sequence can be used:
		<pre>
				register-use
				signal-name-index
		</pre>
		and directly invoke a name "by the index".
		<p>
		This is the rationale behind <a href="../ISignalWriteFormat.html#BEGIN">ISignalWriteFormat.begin(String,boolean)</a>
		second argument. 
		
		
		<h1>Internal signals</h1>
		The <a href="../IDescribedSignalReadFormat.html">IDescribedSignalReadFormat</a>
		declares 16 codes which are to be returned to indicate certain primitive data.
		<p>
		Reader should notice that those codes will be used practically everywhere and will
		surround practically every data.
		<p>
		This is wise then to have for them as compact indicators as possible.
		<p>
		We then assume that our stream must support, or at least declare support of, except of
		<code>begin-signal-indication</code><code>end-signal-indication</code>
		all the dedicated indicators for all that elements. They can be no-op for undescribed streams
		but the should be declared at abstract level.
		
</body>
</html>
