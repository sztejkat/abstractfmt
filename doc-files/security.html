<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>sztejkat.abstractfmt - security issues</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=UTF-8">
</head>
<body>
	In this chapter I will discuss some security/safety issues.

        <h1 id="OOMEVENT_NAME">Event name out of memory attack</h1>
        Since the stream <a href="../ISignalWriter.html#BEGIN">writer</a>
        declares an ability to write an arbitraty name to a stream
        the reading end must be prepared to read it from a stream and
        return to a user.
        <p>
        The reading of a signal name takes place in reader
        <a href="../ISignalReader.html#NEXT">next()</a> method and
        the entire process is hidden from a user.
        <p>
        One may imagine than an attacker may formulate a fake stream
        with name of such a length, that a process of composing it
        in memory at the receiving end will cause OutOfMemory exception
        inside a <code>next()</code>.
        <p>
        Notice, this is not as impossible as it looks like because:
        <ul>
            <li>stream may be procedurally generated at zero memory cost
            at attacker;</li>
            <li><code>StringBuilder</code> is not a very carefull about
            memory allocation and in:
            <pre>
            private int newCapacity(int minCapacity) {
            (...)
                    int newCapacity = (oldCapacity &lt;&lt; 1) + 2;
            </pre>
            is using an operation which basically doubles the size
            of needed memory. One may expect then, that requesting
            string of 1/3 of available heap space will with great
            probability trigger OutOfMemory exception.
        </ul>

       <h1 id="OOMEVENT_API">Sequence API out of memory attack</h1>
       The analogous to <a href="#OOMEVENT_NAME">event name attack</a>
       could have happen in any API which would look like:
       <pre>
       String readString()...
       byte [] readByte()...
       </pre>
       and etc. 
       <p>
       Due to that reasons such an API is NOT defined and each API takes
       directly the maximum length of an operation as an argument.
       
       
       <h1 id="OOMEVENT_XML">XML attribute out-of-memory attack</h1>
       Whatever to say about XML it is very difficoult to say
       that parsers are robust. The good example is the 
       plain good old:
       <pre>
       	&lt;tag name="............... x 2^32
       </pre>
       Most parsers will make all possible attempts to load this
       attribute name to memory and thous crash the target machine.
       
       
       
       
        <h1 id="STACK_OVERFLOW_ATTACK">Stack overflow attack</h1>
        If the format allows nesting elements inside element, like for
        an example XML do and this proposed format does then there is always
        a probability that users will decide to parse the incomming stream
        as:
        <pre>
        processStructure(....)
        {
        	....
        	switch(next())
        	{
        		case "structure": processStructure(...); break;
        		...
        	}
        }
        </pre>
        This style of processing is natural for any form of serialization
        and is clear and easy to write.
        <p>
        The problem is that attacker may form a stream which so much nested 
        "structure" elements that the thread control stack will overflow.
        <p>
        The depth necessary to trigger stack overflow is tens of orders of magnitude
        smaller that the size of data necessary to trigger OutOfMemory attacks and
        will be the smaller the more local variables the routine needs.
        <p>
        Thous formats should allow, optionally, to throw if recursion is too deep.
</body>
</html>
