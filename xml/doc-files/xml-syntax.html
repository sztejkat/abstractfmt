<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>sztejkat.abstractfmt.xml - XML format definition</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=UTF-8">
</head>
<body>
	<h1>XML format definition</h1>
	This document carries a definition of XML format used by 
	classes in this package.
	
	<h2>Basic informations</h2>
	<ol>
		<li>This format is <u>case sensitive</u>;</li>
		<li>This format is using a restricted, tunable set of XML <code>&amp;xxx;</code> escapes.
		To find about what escapes are implemented check <a href="../SXMLSettings.html">SXMLSettings</a>;</li>
		<li>To represent characters which are not allowed even after
		<code>&amp;xxx;</code> escaping or cannot be correctly encoded using
		current charset this stream is using <a href="#ESCAPING">own escape sequence.</a>;</li>
		<li>This stream silently ignores add XML comments (<code>&lt;!-- --&gt;</code>) and (except in prolog processing)
		all XML	processing commands (<code>&lt;?  ?&gt;</code>);</li>
		<li>This stream is normalizing whitespaces using:
			<ul>
				<li>Each whitespace is replaced with ' ' (d32);</li>
				<li>If there is &gt; or &lt; right before the whitespace
				the whitespace is removed;</li>
				<li>If there is &lt; or &gt; right after the whitespace,
				the whitespace is removed;</li>
				<li>If there is a whitespace after right after
				 the whitespace, the whitespace is removed;</li>
			</ul>
			where "whitespace" is any Java "whitespace" (' '\n\t,page feed and etc.).
	    </li>
	    <li>All tags, escapes and etc. are configurable;</li>
	</ol>
	
	<h1>Deviations from XML standard</h1>	
	This package defines two levels of XML support:
	<ul>
		<li><a href="#BARE">"bare xml"</a>, without neither XML prolog or epilog;</li>
		<li><a href="#FULL">"full xml"</a>, with them.</li>
	</ul>
	This package also implements comments skipping and processing elements skipping
	and white space normalization in that order and as a stream-line service. Thous
	it may deviate from standard if &lt;&gt; characters are used in attribute values.
	Due to that this format never generates in bodies or attribute values
	any characters which are registered as known XML <code>&amp;xx;</code> escapes.
	<p>
	
	The fact, that XML restricts the set of allowed characters together with 
	an assumption that we need support full 0...65535 UTF-16 chars requires
	that we do some <a href="#ESCAPING">escaping</a>.
	
	
	
	<h2 id="BARE">Bare XML format</h2>
	The bare XML format implementation in this package
	does not contain neither XML <i>prolog</i> nor <i>root</i> XML element which is
	enclosing every data within. 
	<p>
	Instead it is assumed to be a plain sequence of XML elements
	designed in such a way, that in any moment next element may
	be appended at the end of stream.
	<p>
	Bare XML format is <u>not well formed</u>.
	
	
	<h2 id="FULL">Full XML format</h2>
	The full XML format carries user configurable prolog, like for an example:
	<pre>
		&lt;?xml version="1.0" encoding="xxxx" ?&gt; &lt;?sztejkat.abstractfmt.xml?&gt;
	</pre>
	and may use configurable root element to enclose all data, like for an example:
	<pre> 
		&lt;root&gt;
		....
		&lt;/root&gt;
	</pre>
	
	<h1 id="ESCAPING">Escaped characters</h1>
	<h2>Why escaping is necessary</h2>
	<i>Note: Usually XML escaping deals with <code>&amp;#XX;</code> escaping and people
	are silent about the fact, that this type of escaping is processed after XML entities
	are detected, but before they are processed. This means that this kind of escaping
	will be un-escaped by XML parsers and characters which can't be
	used in that location won't be allowed even if written in <code>&amp;#XX</code> form.</i>
	<p>
	Since we need to support the whole UTF16 (java <code>char</code>) space we can't
	use standard escapes.
	
	<h2>Escape sequence</h2>
	We then define an escape sequence as:
	<pre>
		%x;
		%xx;
		%xxx;
		%xxxx;
		%%;
	</pre>
	where <code>x</code> is a hex code of character (upper case, most significant digit on left) 
	and <code>%%;</code> represents
	escaped <code>%</code> character.
	<p>
	<i>Note: Both % and ; are configurable.</i>
	
	<h2 id="ESCAPED_CHAR_ARRAY">Escaped content inside XML tag body</h2>
	The body of of XML tag is written in such a way	that if character is:
	<ol>
			<li>Not within:
			<pre>
			[#x20-#xD7FF] | [#xE000-#xFFFD]
			</pre>
			or</li>
			<li>Within:
			<pre>
				[#x7F-#x84], [#x86-#x9F], [#xFDD0-#xFDDF],
				//Note: below are surogate pairs which we do not support.
				[#x1FFFE-#x1FFFF], [#x2FFFE-#x2FFFF], [#x3FFFE-#x3FFFF],
				[#x4FFFE-#x4FFFF], [#x5FFFE-#x5FFFF], [#x6FFFE-#x6FFFF],
				[#x7FFFE-#x7FFFF], [#x8FFFE-#x8FFFF], [#x9FFFE-#x9FFFF],
				[#xAFFFE-#xAFFFF], [#xBFFFE-#xBFFFF], [#xCFFFE-#xCFFFF],
				[#xDFFFE-#xDFFFF], [#xEFFFE-#xEFFFF], [#xFFFFE-#xFFFFF]
			</pre>
			</li>
			or
		</li>
		<li>Is one of <code>&gt;&lt;&amp;</code> or <code>%</code> (configurable) or</li>
		<li>is registered <code>&amp;xx;</code> escape or</li>
		<li>cannot be encoded using current charset or;</li>
		<li>Is Java white-space (inclues eol, page feed, tabs, etc)</li>
	</ol>
	then it is escaped. If it is registered  <code>&amp;xx;</code> escape 
	standards XML  <code>&amp;xx;</code> escape  is used. If it is not,
	our escape method is used.
	
	<h2 id="ESCAPED_ATTR">Escaped characters in signal name passed as an attribute</h2>
	When a signal name is passes as an XML attribute it is encoded
	as if in body would be with an addition that some additional
	charactes are also escaped.
	<p>
	Those characters are: <code>"'</code> 
	
	
	<h2>Begin signal</h2>
	XML format does not support <i>names registry</i> provided by <code>ASignalWriteFormat</code>
	and is always using directly stored signal names. This is because a primary reason for
	using XML is to have a human readable data and replacing event names with numbers would
	defeat it.
	<p>
	<i>Note: Altough XML definition says that valid element name
	is <code>	Name	   ::=   	(Letter | '_' | ':') (NameChar)*</code>
	the Firefox and others do intensively use : as a name-space separator and
	do intensively complain if something is wrong with namespaces.
	This terribly restricts the possible range of allowed XML names.
	Due to this restriction I can't effectively handle encoded signal
	names as direct xml entities</i>
	<p>
	If the begin signal name:
	<ul>
		<li>starts with java letter;</li>
		<li>contains only letters, digits or <code>_-.</code>   ;</li>
		<li>does not equal to any element names specified in this format;</li>
	</ul>
	then begin signal is written as:
	<pre id="short_signal_form">
		&lt;<i>signal_name</i>&gt;
	</pre>
	otherwise it is written as
	<pre id="long_signal_form">
		&lt;e n="<i>escaped_signal_name</i>"&gt;
	</pre>
	<p>
	where <code>signal_name</code> is a stright forward name and <code>escaped_signal_name</code>
	is <a href="#ESCAPED_ATTR">escaped</a>.
	<p>
	<i>Note: Both "e" and "n" are configurable.</i>
	
	<h2>End signal</h2>
	End signal is written, accordingly to form use at begin:
	<pre>
		&lt;/<i>signal_name</i>&gt;
	</pre>
	or
	<pre>
		&lt;/e&gt;
	</pre>
	
	
	<h2>Elementary primitives</h2>
	Primitives are written in their textual form as a sequence
	of <i>primitive tokens</i> separated either by 
	XML elements or <i>primitive separator</i>.
	<p>
	The <code id="primitive_separator">;</code> (semicolon, configurable) is used
	as a primitive separator if there is no <code>&lt;</code> XML element
	start character right after the primitive value.
	<p>
	Example:
	<pre>
	<i>undescribed:</i>
		1;3;4;
	<i>described:</i>
		&lt;i&gt;1&lt;/i&gt;&lt;i&gt;2&lt;/i&gt;&lt;i&gt;3&lt;/i&gt;
	</pre>
	
	<h3 id="enc_numeric">byte, short, int, long, float, double</h3>
	Since XML must be human readable all primitives are coded as decimal numbers
	with optional negative sign and dot as decimal separator. Scientific format
	can be used for floating points.
	
	<h3 id="enc_boolean">boolean</h3>
	Boolean is represented as <code>t</code> (true) or <code>f</code> (false).
	This is case sensitive.
	<p>
	<i>Note:Reading end of format is expected to accept also T,F,0,1 as valid
	values.</i>
	
	<h2 id="enc_char">Characters</h2>
	Are escaped. The <a href="#primitive_separator">primitive separator</a>
	and white spaces are included in set of escaped characters.
	<p>
	If primitives separator char is the same as escape sequence terminating
	char then primitives separator is skipped and only sequence terminating char
	 is used,ie:
	<pre>
		; &larr; both separators are semicolon.
		<i>sequence of two char primitives looks like:</i>
		%0;%434;
	</pre>
	
	<h2 id="primitive_elements">Described format</h2>
	Following elements are used to enclose each elementary primitive in
	described format:
	<ul>
		<li><code>&lt;o&gt;</code> for boolean;</li>
		<li><code>&lt;b&gt;</code> for bytes;</li>
		<li><code>&lt;c&gt;</code> for chars;</li>
		<li><code>&lt;s&gt;</code> for short;</li>
		<li><code>&lt;i&gt;</code> for integers;</li>
		<li><code>&lt;l&gt;</code> for long;</li>
		<li><code>&lt;f&gt;</code> for float;</li>
		<li><code>&lt;d&gt;</code> for doubles;</li>
	</ul>
	<p>
	<i>
	Note:Names of all elements are configurable.
	</i>
	
	<h1>Blocks of primitives</h1>
	Blocks of primitives are used to carry a tightly packed content but 
	most of them must be human readable.
	
	<h2 id="enc_boolean_blk">boolean []</h2>
	Boolean blocks are represented as a continous sequence of <code>t</code> or <code>f</code>
	without any separators.	
	
	<h2 id="enc_byte_blk">byte []</h2>
	Since byte blocks will be most frequently used to store raw data they do not
	have to be human readable. Instead they are represented as a sequence
	of hex digits pairs, most significant on left, upper case, without any separator.
	
	<h2 id="enc_char_blk">char []</h2>
	Character blocks are represented as encoded texts.
	<p>
	Writers are required to escape all white spaces, eols, tabs and etc.
	
	
	
	
	<h3 id="end_numeric_blk">short [], int[], long [],float[], double[]</h3>
	Due to necessary readability they are stored as if were written with
	a sequence of un-described elementary primitive writes.
	
	<h2>Described format</h2>
	Following elements are used to enclose each primitive block in
	described format:
	<ul>
		<li><code>&lt;oa&gt;</code> for boolean [];</li>
		<li><code>&lt;ba&gt;</code> for bytes [];</li>
		<li><code>&lt;ca&gt;</code> for chars [];</li>
		<li><code>&lt;sa&gt;</code> for short [];</li>
		<li><code>&lt;ia&gt;</code> for integers [];</li>
		<li><code>&lt;la&gt;</code> for long [];</li>
		<li><code>&lt;fa&gt;</code> for float [];</li>
		<li><code>&lt;da&gt;</code> for doubles [];</li>
	</ul>
	<p>
	<i>
	Note:Names of all elements are configurable.
	</i>
	
</body>
</html>
