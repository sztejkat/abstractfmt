<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>sztejkat.abstractfmt.xml - XML format definition</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=UTF-8">
</head>
<body>
	This document carries a definition of XML format used by 
	classes in this package.
	
	<h1>Deviations from XML standard</h1>
	<i>Note: All elements are <u>case sensitive</u></i>
	This package defines two levels of XML support:
	<ul>
		<li><a href="#BARE">"bare xml"</a>, without neither XML prolog or epilog;</li>
		<li><a href="#FULL">"full xml"</a>, with them.</li>
	</ul>
	The fact, that XML restricts the set of allowed characters together with 
	an assumption that we need support full 0...65535 UTF-16 chars requires
	that we do some <a href="#ESCAPING">escaping</a>.
	<p>
	Comments are also processed with <a href="#COMMENTS">some deviation from a standard</a>.
	<h2 id="BARE">Bare XML format</h2>
	The bare XML format implementation in this package
	does not contain neither XML <i>prolog</i> nor <i>root</i> XML element which is
	enclosing every data within. 
	<p>
	Instead it is assumed to be a plain sequence of XML elements
	designed in such a way, that in any moment next element may
	be appended at the end of stream.
	<p>
	Bare XML format is <u>not well formed</u>.
	
	
	<h2 id="FULL">Full XML format</h2>
	The full XML format carries following prolog:
	<pre>
		&lt;?xml version="1.0" encoding="xxxx" ?&gt; &lt;!-- <i>writer class name</i> --&gt; 
		&lt;root&gt;
		....
		&lt;/root&gt;
	</pre>
	where <i>xxx</i> is a name of an encoding used and <code>root</code> is configurable.
	The <i>writer class name</i> is a user defined comment, usually recommended to be a name
	of a class which wrote data.
	
	<h1 id="ESCAPING">Escaped characters</h1>
	<h2>Why escaping is necessary</h2>
	<i>Note: Usually XML escaping deals with <code>&amp;#XX;</code> escaping and people
	are silent about the fact, that this type of escaping is processed after XML entities
	are detected, but before they are processed. This means that this kind of escaping
	will be un-escaped by XML parsers and characters which can't be
	used in that location won't be allowed even if written in <code>&amp;#XX</code> form.</i>
	<p>
	Since we need to support the whole UTF16 (java <code>char</code>) space we can't
	use standard escapes.
	<p>
	Second, the XML parsers do treat text in both elements and attributes as if
	spaces and EOL were something that has no meaning and are basically replacing all
	white space sequences with a single white space and all line ends with 
	no line end.
	<h2>Escape sequence</h2>
	We then define an escape sequence as:
	<pre>
		%x;
		%xx;
		%xxx;
		%xxxx;
		%%;
	</pre>
	where <code>x</code> is a hex code of character (upper case, most significant digit on left) 
	and <code>%%;</code> represents
	escaped <code>%</code> character.
	<p>
	<i>Note: Both % and ; are configurable.</i>
	
	<h2 id="ESCAPED_CHAR_ARRAY">Escaped content inside char []</h2>
	<i>See <code>ISignalWriteFormat.writeCharBlock</code> method.</i>
	<p>
	The body of of any <code>char []</code> block is written in such a way
	that if character is:
	<ol>
			<li>Not within:
			<pre>
			[#x20-#xD7FF] | [#xE000-#xFFFD]
			</pre>
			or</li>
			<li>Within:
			<pre>
				[#x7F-#x84], [#x86-#x9F], [#xFDD0-#xFDDF],
				//Note: below are surogate pairs which we do not support.
				[#x1FFFE-#x1FFFF], [#x2FFFE-#x2FFFF], [#x3FFFE-#x3FFFF],
				[#x4FFFE-#x4FFFF], [#x5FFFE-#x5FFFF], [#x6FFFE-#x6FFFF],
				[#x7FFFE-#x7FFFF], [#x8FFFE-#x8FFFF], [#x9FFFE-#x9FFFF],
				[#xAFFFE-#xAFFFF], [#xBFFFE-#xBFFFF], [#xCFFFE-#xCFFFF],
				[#xDFFFE-#xDFFFF], [#xEFFFE-#xEFFFF], [#xFFFFE-#xFFFFF]
			</pre>
			</li>
			or
		</li>
		<li>Is one of <code> &gt;&lt;&amp;%</code> or</li>
		<li>Is Java white-space (inclues eol, page feed, tabs, etc)</li>
	</ol>
	then it is escaped.
	
	<h2 id="ESCAPED_ATTR">Escaped characters in signal name when passes as an attribute</h2>
	When a signal name is passes as an XML attribute it is encoded
	as if <code>char[]</code> block would be with an addition that some additional
	charactes are also escaped.
	<p>
	Those characters are: <code>"'</code> 
	
	
	<h1 id="COMMENTS">XML comments</h1>
	Comments can processed as if regular XML elements thous they do interrupt
	processing of primitive data.
	<p>
	For an example:
	<pre>
		1234&lt;-- comment --&gt;56
	</pre>
	will form two numbers: 1234 and 56 instead of one 123456.
	<p>
	This is a deviation from standard, but implementations are allowed to produce both
	results. Simply using comment inside a primitive element text body should be avoided.
	
	
	<h1 id="WHITESPACES">Whitespeace and EOL</h1>
	<i>Note: "whitespace" means space, tab, eol and anything what JAVA Character
	says <code>isWhitespace</code>.</i>
	<p>
	All whitespaces:
	<ul>
		<li>directly before or after XML tag;</li>
		<li>found under cursor when primitive read (except character block read)
		is performed;</li> 
		<li>found between primtive block elements;</li> 
	</ul>
	are silently skipped and ignored.
	<p>
	That is file:
	<pre>
	&gt;x&lt;ABCDEF&gt;/x&lt;
	</pre>
	and
	<pre>
	&gt;x&lt;	ABCDEF
	&gt;/x&lt;
	</pre>
	are giving the same result.
	<p>
	Since any whitespace before or after the primitive is ignored thous if a begining
	or trailing white space is a part of a primitive it must be escaped.
	<p>
	The only exception from this case is when a character block is processed.
	All character block reads are expected to not skip any whitespaces, 
	but replace the entire sequence with a single <code>d32</code> character. 
	
	
	<h1>Begin signal</h1>
	XML format does not support <i>names registry</i> provided by <code>ASignalWriteFormat</code>
	and is always using directly stored signal names. This is because a primary reason for
	using XML is to have a human readable data and replacing event names with numbers would
	defeat it.
	<p>
	<i>Note: Altough XML definition says that valid element name
	is <code>	Name	   ::=   	(Letter | '_' | ':') (NameChar)*</code>
	the Firefox and others do intensively use : as a name-space separator and
	do intensively complain if something is wrong with namespaces.
	This terribly restricts the possible range of allowed XML names.
	Due to this restriction I can't effectively handle encoded signal
	names as direct xml entities</i>
	<p>
	If the begin signal name:
	<ul>
		<li>starts with java letter;</li>
		<li>contains only letters, digits or <code>_-.</code>   ;</li>
		<li>does not equal to any element names specified in this format;</li>
	</ul>
	then begin signal is written as:
	<pre id="short_signal_form">
		&lt;<i>signal_name</i>&gt;
	</pre>
	otherwise it is written as
	<pre id="long_signal_form">
		&lt;e n="<i>escaped_signal_name</i>"&gt;
	</pre>
	<p>
	where <code>signal_name</code> is a stright forward name and <code>escaped_signal_name</code>
	is <a href="#ESCAPED_ATTR">escaped</a>.
	<p>
	<i>Note: Both "e" and "n" are configurable.</i>
	
	<h1>End signal</h1>
	End signal is written, accordingly to signal name used in begin form as:
	<pre>
		&lt;/<i>signal_name</i>&gt;
	</pre>
	or
	<pre>
		&lt;/e&gt;
	</pre>
	
	
	<h1>Elementary primitives</h1>
	Primitives are written in their textual form as a sequence
	of <i>primitive tokens</i> separated either by 
	XML elements or <i>primitive separator</i>.
	<p>
	The <code id="primitive_separator">;</code> (semicolon, configurable) is used
	as a primitive separator if there is no <code>&lt;</code> XML element
	start character.
	<p>
	Example:
	<pre>
	<i>undescribed:</i>
		1;3;4;
	<i>described:</i>
		&lt;i&gt;1&lt;/i&gt;&lt;i&gt;2&lt;/i&gt;&lt;i&gt;3&lt;/i&gt;
	</pre>
	
	<h2 id="enc_numeric">byte, short, int, long, float, double</h2>
	Since XML must be human readable all primitives are coded as decimal numbers
	with optional negative sign and dot as decimal separator. Scientific format
	can be used for floating points.
	
	<h2 id="enc_boolean">boolean</h2>
	Boolean is represented as <code>t</code> (true) or <code>f</code> (false).
	This is case sensitive.
	
	<h2 id="enc_char">Characters</h2>
	Are escaped. The <a href="#primitive_separator">primitive separator</a>
	and white spaces are included in set of escaped characters.
	<p>
	If primitives separator char is the same as escape sequence terminating
	char then primitives separator is skipped and only sequence terminating char
	 is used,ie:
	<pre>
		; &larr; both separators are semicolon.
		<i>sequence of two char primitives looks like:</i>
		%0;%434;
	</pre>
	
	<h2 id="primitive_elements">Described format</h2>
	Following elements are used to enclose each elementary primitive in
	described format:
	<ul>
		<li><code>&lt;o&gt;</code> for boolean;</li>
		<li><code>&lt;b&gt;</code> for bytes;</li>
		<li><code>&lt;c&gt;</code> for chars;</li>
		<li><code>&lt;s&gt;</code> for short;</li>
		<li><code>&lt;i&gt;</code> for integers;</li>
		<li><code>&lt;l&gt;</code> for long;</li>
		<li><code>&lt;f&gt;</code> for float;</li>
		<li><code>&lt;d&gt;</code> for doubles;</li>
	</ul>
	<p>
	<i>
	Note:Names of all elements are configurable.
	</i>
	
	<h1>Blocks of primitives</h1>
	Blocks of primitives are used to carry a tightly packed content but 
	most of them must be human readable.
	
	<h2 id="enc_boolean_blk">boolean []</h2>
	Boolean blocks are represented as a continous sequence of <code>t</code> or <code>f</code>
	without any separators.	
	
	<h2 id="enc_byte_blk">byte []</h2>
	Since byte blocks will be most frequently used to store raw data they do not
	have to be human readable. Instead they are represented as a sequence
	of hex digits pairs, most significant on left, upper case, without any separator.
	
	<h2 id="enc_char_blk">char []</h2>
	Character blocks are represented as encoded texts.
	<p>
	Writers are required to escape all white spaces, eols, tabs and etc. and not
	write any <a href="#WHITESPACES">leading or traling whitespaces and eols</a>.
	<p>
	Readers are required to process text as:
	<ul>
		<li>skip all <a href="#WHITESPACES">leading and trailing whitespaces and eols</a>;</li>
		<li>replace all <code>\n\r</code>, <code>\r\n</code> and 
		 <code>\r</code> to <code>\n</code> character;</li>
		<li>unescape all found escapes;</li>
	</ul>
	This should allow both precise and accurate representation and allow manual for editing,
	with fixed well defined, user editor indepentent EOL convention.
	
	
	
	
	<h3 id="end_numeric_blk">short [], int[], long [],float[], double[]</h3>
	Due to necessary readability they are stored as if were written with
	a sequence of un-described elementary primitive writes.
	
	<h2>Described format</h2>
	Following elements are used to enclose each primitive block in
	described format:
	<ul>
		<li><code>&lt;oa&gt;</code> for boolean [];</li>
		<li><code>&lt;ba&gt;</code> for bytes [];</li>
		<li><code>&lt;ca&gt;</code> for chars [];</li>
		<li><code>&lt;sa&gt;</code> for short [];</li>
		<li><code>&lt;ia&gt;</code> for integers [];</li>
		<li><code>&lt;la&gt;</code> for long [];</li>
		<li><code>&lt;fa&gt;</code> for float [];</li>
		<li><code>&lt;da&gt;</code> for doubles [];</li>
	</ul>
	<p>
	<i>
	Note:Names of all elements are configurable.
	</i>
	
</body>
</html>
