<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>sztejkat.abstractfmt.txt.plain</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=UTF-8">
</head>
<body>
      An oversimplified text format laid directly on
      <code>sztejkat.abstractfmt.txt</code> engines.
      
      <h1>Format description</h1>
      This format does not implement neither "end-begin" optimization nor name
      registry.
      <h2>Encoding</h2>
      A text format using UTF-8 encoding.
      All characters are allowed, BOM on the beginning of stream is not allowed.
      <p>
      Note: A standard JAVA UTF-8 encoder do obey the rule:
      <i>(...)
       <br>
       The UCS code values 0xd800â€“0xdfff (UTF-16 surrogates) as well as
       0xfffe and 0xffff (UCS noncharacters) should not appear in
       conforming UTF-8 streams.<br>
       (...)
       </i><br>
      what is a very sad thing, because it forces us to use a far more complex
      escaping as one may expect.


      
      
      <h1>Sytax description</h1>
      The syntax definiion is using a simplfied BNF notation
      <pre>
           a:= expression &larr; syntax element defined by an "expression"
      </pre>
      where expression is a either
      <pre>
      		sytax_element <i>operator</i>
      </pre>
      or
      <pre>
      		character <i>operator</i>
      </pre>
      where operator is optional and can be:
      <pre>
      	* - zero or more times
      	| - or
      	() - grouped expression
      	+ - one or more time
      	? - zero or one time.
      	?n - up to n times
      </pre>
      and characters are:
      <pre>
      	class:<i>description of character class</i> - specific unicode class
      	. - any character
      	[a-z,0-9] - any character from within range
      	^[a-z,0-9] - any character except those from within range
      </pre>
      
      
      <h1>Syntax definition</h1>
      The whole stream is defined as:
      <pre>
      	stream:= stream_element *
      </pre>
      where
      <pre>
      	stream_element:=
      					comment |
      					empty_character |
      					struct |
      					content ( empty_character* , empty_character* content)*
      	content:=
      				plain_token  |
      				quoted_token 
      	
      	comment:= # (^[newline_character])*
      	empty_character:= class:unicode whitespace, including new-lines
      	plain_token:= (^[empty_character , ; * # " , 0xD800-0xDFFF])*
      	quoted_token:= " (^[" | 0xD800-0xDFFF ] | escape )* "
      	escape:= (\\ | \[0-9,a-f,A-F]?4; | \" )
      	struct:= begin stream_element* end 
      	begin:= [*]plain_token |
      			[*]quoted_token
      	end:= ;
      </pre>
      what would be in a less formal terms:
      <ul>
      	<li>comment starts with # and lasts till end of line. Comments can happen anywhere, including
      	inside plain tokens but exluding quoted tokens and do not affect syntax;</li>
      	<li>plain tokens is made of non-white-spaces and excludes ,;*"# and <u>surogates</u>, even correct;</li>
      	<li>quoted token is made of any characters enclosed in "" where \ is used as an escape character
      	allowing directly escape any <code>0...0xFFFF</code> Java char value (not unicode code-point!) \" to escape double-quote
      	and \\ to escape \. We do allow unescaped correct surogates
      	<p>
      	The escaping allows <u>up to</u> four digits and requires terminating ;.
      	<p>
      	Good escapes are:
      	<pre>
      	\3Af7;
      	\0000;
      	\; &rarr; \0000; 
      	\fe; \00FE;
      	</pre>
      	;</li>
      	<li>tokens are separated by any white-spaces and ,;</li>
      	<li>struct starts with * followed by name of begin signal and terminates with ; </li>
      	<li>You don't need , between structs;</li>
      	<li>two consequenct , , with any spaces do indicate an empty token;</li>
      </ul>
      <h2>Examples</h2>
      <pre>
      # This is a file
      *start; # this is an empty structure
      123,
      33,44,"55" #those are numbers
      *"#complex name"33,"string of martini"; #and a structure with a content.
      </pre>
      
      <h1>Parsing tokens</h1>
      This format is using rules found in <code>sztejkat.abstractfmt.txt.ATxtReadFormat0</code>
      and basically does everything possible to parse tokens or fragments of them into
      what You do request.
</body>
</html>
