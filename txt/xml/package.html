<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>sztejkat.abstractfmt.txt.xml</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=UTF-8">
</head>
<body>
      This package defines how signal format is projected on XML file.

      <h1>Use of XML standard</h1>
      This format do produce "well formed XML 1.1", but cannot parse all
      "well formed" XMLs.
      <p>
      Note: Refer to XML specification <a href="https://www.w3.org/TR/xml/">there</a>
      or a <a href="doc-files/xml1.1/XML_specification.html">copy</a> provided with this package
      for Your convinience.
      
      <h3>Breaking change</h3>
      The XML 1.0 Ed 5 introduced a "breaking change" by allowing characters which were not
      allwed in XML 1.0 Ed 4 and below <u>without</u> bumping up version in XML prolog.
      This results in incompatibility and files produced with Ed 5 are not well formed when
      processed by parsers of Ed 4 and below. Which, by the way, are default for JDK8...11 and 
      Firefox. 
      <p>
      The correct edition was introduced <u>earlier</u> in 2006 in a form of XML 1.1. The XML 1.0
      was bumped up to same character set in 2008 what created a "breaking change". How they could
      miss that? I can't imagine. 
      <p>
      Thous I actually had a choice: to stay at 1.0 Ed4 or to select 1.1. The last choice seems
      to be more logic and coherent as up to now (2023) it does not generated any "breaking changes". 
      
      <h1>Restrictions on parsing</h1>
      During parsing the classes implementing signal format over the XML
      are expected to:
      <ul>
      	<li>support only required set of entities, as by 4.6 of specification:
      	<code>lt, gt, amp, apos, quot</code>;
      	<li>ignore declarations of named entities, either internal or external;</li>
      	<li>ignore CDATA sections;</li>
      	<li>ignore processing ? instructions;</li>
      	<li>ignore NOTATION sections;</li>
      	<li>ignore DOCTYPE syntax declaration;</li>
      </ul>
      
      <h1>XML schema</h1>
      The format is schema-less since there is no way to define schema
      for unknown data structures.

      <h1>Main XML element</h1>
      Opening stream writes XML prolog:
      <pre>
      	&lt;?xml version="1.1" encoding="UTF-8" ?&gt;
      	&lt;xml&gt;
      </pre>
      <p>
      Closing stream does:
      	<ul>
      		<li>if signal <u>recursion depth is zero</u> writes XML tag
      		closing xml element opened in prolog;</li>
      		<li>if signal recustion depth is NOT zero, all XML tags
      		which were open but not closed are left as they are, and
      		it is not closing the tag for an element opened in prolog.
      		</li>
      		
      	</ul>
      This method was selected because even tough closing a stream with 
      un-closed signals will produce a faulty XML I find it still better
      than faking the correctness by forcibly closing the dangling tags.

    
      

      <h1>XML comments</h1>
      Supported everywhere where XML allows them. The XML comment, alike in XML,
      do affect the parser and is seen as a <a href="#TOKENS">"token" terminator</a>. 
      

      
      <h1>Adaptation of XML to signal format</h1>
      
      <h2>Begin signal</h2>
      Begin signal is always encoded directly, without any names registry nor optimization
      and is represented as an opening XML tag:
      <pre>
            &lt;<i>nnnn</i>&gt;
      </pre>
      where <code>nnnn</code> is a signal name, with not allowed characters <a href="#ESCAPE">escaped</a>.
      <p>
      Since XML element name cannot be empty for some unknown reason the
      empty name is encoded as a single '_'. 

      
      
      <h2>End signal</h2>
      End signal in XML cannot be anonymous and must be encoded alike <code>begin</code> signal:
      <pre>
            &lt;/<i>nnnn</i>&gt;
      </pre>
      <p>
      <i>Note: The inablity to use "anonymous closing tag" <code> &lt;/&gt;</code>
      enforces stream writer to keep track of opened signals on a stack what may
      cause excesive memory consumption. Thous XML format do have some natural limit
      for recursion depth.</i>

      
      
      <h2 id="TOKENS">XML element body</h2>
      Inside an XML element body elementary primitives are stored one by one, using "tokens" separated by <code>,</code> and optional
      ignorable white spaces. There are two kinds of tokens:
      <ul>
      	<li>"plain tokens", which can't contain the <code>,"</code> or white-space character;</li>
      	<li id="STRTOKEN">"string tokens", which are enclosed in " and can contain any text;</li>
      </ul>
      The syntax which tells how primitive elements are turned into "tokens"
      is described in <a href="../ATxtWriteFormat0.html">sztejkat.abstractfmt.txt.ATxtWriteFormat0</a>
      class. 

      
      
      <h2>Parsing</h2>
      The signals are parsed as usual XML elements.
      <p>
      The body of XML element is parsed as a sequence of comma separated "tokens", either enclosed in "" or not.
      <h2>Parsing tokens</h2>
      <i><small>Note: those are the same rules as for <code>sztejkat.abstractfmt.txt.plain</code> format.</small></i><br>
      This format do write tokens using <code>sztejkat.abstractfmt.txt.ATxtReadFormat1</code> formating style
      and parses using <code>sztejkat.abstractfmt.txt.ATxtReadFormat0</code> rules.
      <p>
      From less formal point of view it means that:
      <ul>
      	<li>for formating:
      		<ul>
      			<li>all numeric values are encoded as decimals;</li>
      			<li>booleans are encoded as "t" or "f";</li>
      			<li>characters or string writes are always written as quoted tokens and are stitched together
      			into one long token;</li>
      			<li>comments are never written automatically, but API allows for that;</li>
      		</ul>
      	</li>
      	<li>for parsing:
		  <ul>
			<li>it doesn't matter if token is quoted or plain, the inside of it is processed regardless of a form;</li>
			<li>numeric <code>readXXX</code> always do load the whole token and are trying to parse it into a number
			of any float or integer form and interprete it, using everything Java can do. 
			The size of token is limited to a sane value and stream
			complains if it is too long;</li>
			<li>boolean reading additionally understands "true","t","false","f" case insensitive tokens;</li>
			<li>character or string methods always do process tokens character by character and transparently cross
			the token boundaries;</li>
		  </ul>
		 </li>
	</ul>
      
      
      
      

      <h1 id="INVALID_CHARACTER">Invalid characters</h1>
      XML defines following classes off "cannot encode" characters:
      <ul>
          <li>characters which are proper XML characters, but cannot be
          encoded using current low level character encoding;</li>
          <li>characters which cannot be used in XML regardless of how they are
          presented. These are mostly "invalid" unicode code-point, but not always;</li>
          <li>characters which are valid but cannot be used for tag names, attribute names and etc;</li>
      </ul>
      First type of characters can be encoded using known set of entities in style
      <pre>
            &amp;<i>entity mnemonic</i>;
            &amp;#<i>unicode</i>;
      </pre>
      Second type of characters cannot be present in XML file at all. Our abstract
      format do require however, that the entire 0...0xFFFF space of JAVA
      characters can be used for names, elementary characters and strings.
      No XML escape or any other defined method allows to embedd them in XML file.
      <p>
      The set of characters which can begin an XML element name is even more restrictive.
      We however have to be able to use the whole set of JAVA characters
      in XML elements name, so we have to somehow <i>escape</i> them. The escape convention
      should be able to escape everything and be used in <u>any XML context</u>.
      <p>      
      The first character of XML element must be the "base char" what excludes
      any reasonable escape selection past true letters or _ or :.
      <p>
      Where in fact : is also excluded due to later use for "namespace" handling 
      (not XML base standard scope, but 99% of parsers do reserve : for namespace separator).
      <p>
      This means, that _ (U+005F, 95 decimal) is the only reasonable escape character we can actually use
      for an escape.
      
      
      
      
      <h2 id="ESCAPE">Escaping invalid character</h2>
      The Java character (not code-point) which can't be, for any reason, passed directly to
      an XML file is encoded as:
      <pre>
      	_HHHH
      	<i>or</i>
      	_<i>white space character</i>
      </pre>
      where H are <u>exactly</u> four hexadecimal digits representing
      the Java <code>char</code> in question. Upper case is used during generation, but
      both upper and lower case is accepted during parsing.
      <p>
      The _ followed by white-space character is understood as "void", zero size character.
      <p>
      The '_' can be encoded in three forms:
      <ul>
      	<li>'__' or;</li>
      	<li>'_005F' ;</li>
      	<li>'&amp;#x5F;' ;</li>
      </ul>
      Two first forms of an escape can appear in XML elements names while <code>&amp;#xHHH;</code>
      form can't. 
      
      
      
      <h2>Parsing escapes</h2>
      All escapes are parsed <u>after</u> XML syntax is processed and <u>after</u> XML element
      body is split into <a href="#TOKENS">tokens</a>.
      <p>
      If '_' starting an escape sequence is a last character in a sequence which is to
      be un-escaped it is skipped and results in no character production.
      <p>
      Otherwise it must be followed either by four hex digits, upper or lower case or '_'.
      It is an error if it is followed by anything else.
      
      
      <h2>What is escaped?</h2>
      <ol>
      	<li>the XML element names (thous begin signal names) are escaped using <code>_HHHH</code> syntax;</li>
      	<li>the <a href="#STRTOKEN">"string token"</a> body is escaped using
      	primary the <code>&amp;#xXXX;</a> XML syntax and only characters which 
      	can't be present in XML are escaped using <code>_HHHH</code> syntax.
      	This means that _ can be either __ or _005F or &amp;#95; or &amp;#x5F;.
      	<p>
      	Notice that "plain tokens" are not escaped as by definition they
      	can't contain unprocessable characters;</li>
      	<li>comments, generated by API, are escaped using only <code>&amp;#xXXX;</a>
      	XML syntax and do not allow characters which can't be contained inside an
      	XML;</li>
      </ol>
      

</body>
</html>
