<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>sztejkat.abstractfmt.txt.xml</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=UTF-8">
</head>
<body>
      This package defines how signal format is projected on XML file.

      <h1>Use of XML standard</h1>
      This format do produce "well formed XML", but cannot parse all
      "well formed" XMLs.
      <p>
      Note: Refer to XML specification <a href="https://www.w3.org/TR/xml/">there</a>
      or a <a href="doc-files/XML_specification.html">copy</a> provided with this package
      for Your convinience.
      
      <h1>Restrictions on parsing</h1>
      During parsing the classes implementing signal format over the XML
      are expected to:
      <ul>
      	<li>support only required set of entities, as by 4.6 of specification:
      	<code>lt, gt, amp, apos, quot</code>;
      	<li>ignore declarations of named entities, either internal or external;</li>
      	<li>ignore CDATA sections;</li>
      	<li>ignore processing ? instructions;</li>
      	<li>ignore NOTATION sections;</li>
      	<li>ignore DOCTYPE syntax declaration;</li>
      </ul>
      
      <h1>XML schema</h1>
      The format is schema-less since there is no way to define schema
      for unknown data structures.

      <h1>XML body</h1>
      Opening stream writes XML prolog (defined by an implementation).
      <p>
      Closing stream does:
      	<ul>
      		<li>if signal <u>recursion depth is zero</u> writes XML tag
      		closing xml element opened in prolog;</li>
      		<li>if signal recustion depth is NOT zero, all XML tags
      		which were open but not closed are left as they are, and
      		it is not closing the tag for an element opened in prolog.
      		</li>
      	</ul>
      This method was selected because even tough closing a stream with 
      un-closed signals will produce a faulty XML I find it still better
      than faking the correctness by forcibly closing the dangling tags.

    
      

      <h1>XML comments</h1>
      Supported everywhere where XML allows them. The XML comment, alike in XML,
      do affect the parser and is seen as a <a href="#TOKENS">"token" terminator</a>. 
      

      
      <h1>Adaptation of XML to signal format</h1>
      
      <h2>Begin signal</h2>
      Begin signal is always encoded directly, without any names registry nor optimization
      and is represented as an opening XML tag:
      <pre>
            &lt;<i>nnnn</i>&gt;
      </pre>
      where <code>nnnn</code> is a signal name, with not allowed characters <a href="#ESCAPE">escaped</a>.

      
      
      <h2>End signal</h2>
      End signal in XML cannot be anonymous and must be encoded alike <code>begin</code> signal:
      <pre>
            &lt;/<i>nnnn</i>&gt;
      </pre>
      <p>
      <i>Note: The inablity to use "anonymous closing tag" <code> &lt;/&gt;</code>
      enforces stream writer to keep track of opened signals on a stack what may
      cause excesive memory consumption. Thous XML format do have some natural limit
      for recursion depth.</i>

      
      
      <h2 id="TOKENS">XML element body</h2>
      Inside an XML element body elementary primitives are stored one by one, using "tokens" separated by <code>,</code> and optional
      ignorable white spaces. There are two kinds of tokens:
      <ul>
      	<li>"plain tokens", which can't contain the <code>,"</code> or white-space character;</li>
      	<li id="STRTOKEN">"string tokens", which are enclosed in " and can contain any text;</li>
      </ul>
      The syntax which tells how primitive elements are turned into "tokens"
      is described in <a href="../ATxtWriteFormat0.html">sztejkat.abstractfmt.txt.ATxtWriteFormat0</a>
      class. 

      
      
      <h2>Parsing</h2>
      The signals are parsed as usual XML elements.
      <p>
      The body of XML element is parsed as a sequence of comma separated "tokens", either enclosed in "" or not.
      The interpretation of token depends on the method called and details
      are described in <a href="../ATxtReadFormat0.html">sztejkat.abstractfmt.txt.ATxtReadFormat0</a>.
      The parser does everything what is possible to turn token into requested data form. If number read is requested,
      it attempts to do everything standard Java Number types can do. If <code>char</code> is requested it will
      process tokens char-by-char.
      <p>
      The empty token:
      <pre>
      	1,,3
      </pre>
      is understood as numeric 0 or <code>(char)0</code> and this sequence may read as: <code>1,0,3</code>
      or <code>'1',(char)0,'3'</code> depending on what methods are used to process the data.
      <p>
      Note: You should <u>not rely</u> on this ability. Always read the data with the apropriate method. 
      The details of processing may be changed in the future and relying on parsing details will result
      in Your code to be unusable with an another implementations of signal format.
      
      
      
      
      

      <h1 id="INVALID_CHARACTER">Invalid characters</h1>
      XML defines following classes off "cannot encode" characters:
      <ul>
          <li>characters which are proper XML characters, but cannot be
          encoded using current low level character encoding;</li>
          <li>characters which cannot be used in XML regardless of how they are
          presented. These are mostly "invalid" unicode code-point, but not always;</li>
          <li>characters which are valid but cannot be used for tag names, attribute names and etc;</li>
      </ul>
      First type of characters can be encoded using known set of entities in style
      <pre>
            &amp;<i>entity mnemonic</i>;
            &amp;#<i>unicode</i>;
      </pre>
      Second type of characters cannot be present in XML file at all. Our abstract
      format do require however, that the entire 0...0xFFFF space of JAVA
      characters can be used for names, elementary characters and strings.
      No XML escape or any other defined method allows to embedd them in XML file.
      <p>
      The set of characters which can begin an XML element name is even more restrictive.
      We however have to be able to use the whole set of JAVA characters
      in XML elements name, so we have to somehow <i>escape</i> them. The escape convention
      should be able to escape everything and be used in <u>any XML context</u>.
      <p>      
      The first character of XML element must be the "base char" what excludes
      any reasonable escape selection past true letters or _ or :.
      <p>
      Where in fact : is also excluded due to later use for "namespace" handling 
      (not XML base standard scope, but 99% of parsers do reserve : for namespace separator).
      <p>
      This means, that _ (U+005F, 95 decimal) is the only reasonable escape character we can actually use
      for an escape.
      
      
      
      
      <h2 id="ESCAPE">Escaping invalid character</h2>
      The Java character (not code-point) which can't be, for any reason, passed directly to
      an XML file is encoded as:
      <pre>
      	_HHHH
      </pre>
      where H are <u>exactly</u> four hexadecimal digits representing
      the Java <code>char</code> in question. Upper case is used during generation, but
      both upper and lower case is accepted during parsing.
      <p>
      The '_' can be encoded in two forms:
      <ul>
      	<li>'__' or;</li>
      	<li>'_005F' ;</li>
      </ul>
      This form of an escape can appear in XML elements names while <code>&amp;#xHHH;</code>
      form can't. 
      
      
      
      <h2>Parsing escapes</h2>
      All escapes are parsed <u>after</u> XML syntax is processed and <u>after</u> XML element
      body is split into <a href="#TOKENS">tokens</a>.
      
      
      <h2>What is escaped?</h2>
      <ol>
      	<li>the XML element names are escaped using <code>_HHHH</code> syntax;</li>
      	<li>the <a href="#STRTOKEN">"string token"</a> body is escaped using
      	primary the <code>&amp;#xXXX;</a> XML syntax and only characters which 
      	can't be present in XML are escaped using <code>_HHHH</code> syntax.
      	This means that _ can be either __ or _005F or &amp;#95; or &amp;#x5F;.
      	<p>
      	Notice that "plain tokens" are not escaped as by definition they
      	can't contain unprocessable characters;</li>
      	<li>comments, generated by API, are escaped using only <code>&amp;#xXXX;</a>
      	XML syntax and do not allow characters which can't be contained inside an
      	XML;</li>
      </ol>
      

</body>
</html>
