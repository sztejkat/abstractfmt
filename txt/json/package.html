<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>sztejkat.abstractfmt.txt.json</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=UTF-8">
</head>
<body>
      This package defines how signal format is projected on JSON file.

      <h1>Introduction to JSON</h1>
      JSON specs are included in <a href="doc-files/JSON_ECMA-404_2nd_edition.pdf">there</a>.
      <p>
      In short words JSON file is <u>one</u> JSON value which may be 
      a JSON object.
      
      
      <h2>JSON and struct format</h2>
      A JSON file may look like:
      <pre>
      {
      	"field":value,
      	"field":"value",
      	"substructure":{
      					"field":value
      					},
      	"field":[ value, value, { "name":value } ]
      }
      </pre>
      As You can see this format is basically a sequence of grouped
      <i>name/value</i> pairs or a list of <u>un-named</u> values.
      <p>
      At first glance it looks good but the primary problem for us
      is the the {} are not having own name. The name may come only
      from the <i>filed</i> to which JSON object is assigned.
      And elements in list are not named.
      <p>
      In our struct format we do have <u>named</u> object containing
      a list of <u>unnamed</u> values or <u>named</u> objects.
      This might look like:
      <pre>
      	"name"{
      			value,
      			value,
      			value,
      			"name"{ .... }
      	}
      </pre>
      We can't transform it directly to JSON and some tricks will be 
      necessary.
      
      
      
      
      <h1>Structure and stream</h1>
      We assume that the "structure" between <i>begin</i> and <i>end</i> signal
      is always represented in JSON as like:
      <pre>
      {
         "<i>signal_name</i>": [ <i>structure content</i> ]
      }
      </pre>
      More formally speaking we do represent:
      <ul>
      <li>structure with more than one element:
      <pre>
      {
         "<i>signal_name</i>": [ <i>element</i>, <i>element</i>,.... ]
      }
      </pre>
      </li>      
      <li>structure with one <u>primitive element</u>:
      <pre>
      {
         "<i>signal_name</i>": <i>primitive element</i>
      }
      </pre>
      </li>
      
      <li>structure with just <u>string sequence</u> or <u>char sequence</u>:
      <pre>
      {
         "<i>signal_name</i>": "<i>string</i>"
      }
      </pre>
      </li>
      </ul>
      Notice we can't avoid [ ] if structure element is a sub-structure
      because to be able to tell if there is just one element we have to
      delay writing its content to the stream and inject [ before it eventually.
      Delaying the whole structure may be very memory consuming.
      <p>
      We could provide more compactness but it would affect the clarity
      of the processing.
      
      
      <h2>Primitive values</h2>
      Java primitives are converted to matching JSON numbers or logic types.
      <p>
      Characters are converted to JSON string and sequence of character
      writes is stitched into one JSON string. There is no difference between
      strings, char sequences and elementary primitive char writes.
      <p>
      JSON <code>null</code> is not used.
      
      <h3>Escaping characters</h3>
      Since JSON works in a full UTF-16 realm we don't have to be picky and allow everything
      except the bad surogates needs to be escaped directly using JSON syntax.
     
      <h3>Parsing values</h3>
      Generic rules specified in <code>sztejkat.abstractfmt.txt.ATxtReadFormat0</code>
      do apply, so exact type matching between JSON and JAVA is not a special concern.
      
      
      <h2>Stream</h2>
      Since the struct format stream is not a part of a named struct the JSON
      representation of it looks like:
      <pre>
      [
      	<i>structs or elementary primitives</i>,....
      ]
      </pre>
     
      
      

</body>
</html>
