<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>sztejkat.abstractfmt.txt.json</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=UTF-8">
</head>
<body>
      This package defines how signal format is projected on JSON file.

      <h1>Introduction to JSON</h1>
      JSON specs are included in <a href="doc-files/JSON_ECMA-404_2nd_edition.pdf">there</a>.
      <p>
      In short words JSON file is <u>one</u> JSON value which may be 
      a JSON object.
      
      
      <h2>JSON and struct format</h2>
      A JSON file may look like:
      <pre>
      {
      	"field":value,
      	"field":"value",
      	"substructure":{
      					"field":value
      					},
      	"field":[ value, value, { "name":value } ]
      }
      </pre>
      As You can see this format is basically a sequence of grouped
      <i>name/value</i> pairs or a list of <u>un-named</u> values.
      <p>
      At first glance it looks good but the primary problem for us
      is the the {} are not having own name. The name may come only
      from the <i>filed</i> to which JSON object is assigned.
      And elements in list are not named.
      <p>
      In our struct format we do have <u>named</u> object containing
      a list of <u>unnamed</u> values or <u>named</u> objects.
      This might look like:
      <pre>
      	"name"{
      			value,
      			value,
      			value,
      			"name"{ .... }
      	}
      </pre>
      We can't transform it directly to JSON and some tricks will be 
      necessary.
      
      
      
      
      <h1>Structure and stream</h1>
      We assume that the "structure" between <i>begin</i> and <i>end</i> signal
      is always represented in JSON as like:
      <pre>
      {
         "<i>signal_name</i>": [ <i>structure content</i> ]
      }
      </pre>
      More formally speaking we do represent:
      <ul>
      <li>structure with more than one element:
      <pre>
      {
         "<i>signal_name</i>": [ <i>element</i>, <i>element</i>,.... ]
      }
      </pre>
      </li>      
      <li>structure with one <u>primitive element</u>:
      <pre>
      {
         "<i>signal_name</i>": <i>primitive element</i>
      }
      </pre>
      The primitive element is numeric or logic or single character.
      </li>
      <li>structure with no elements:
      <pre>
      {
         "<i>signal_name</i>": []
      }
      </pre>
      The primitive element is numeric or logic or single character.
      </li>
      </ul>
      Notice we can detect "single element structure" only for elementary primitives
      because to do it we have to await for next operation and buffer every written
      character. Buffering strings or sub-structures would require unpredictable
      amount of memory.
      
      
      <h2>Primitive values</h2>
      Java primitives are converted to matching JSON numbers or logic types.
      <p>
      Characters are converted to JSON string and sequence of character
      writes is stitched into one JSON string. There is no difference between
      strings, char sequences and elementary primitive char writes.
      <p>
      JSON <code>null</code> is not used.
      
      <h3>Escaping characters</h3>
      Since JSON works in a full UTF-16 realm we don't have to be picky and allow everything
      except the bad surogates needs to be escaped directly using JSON syntax.
     
      <h3>Parsing values</h3>
      Generic rules specified in <code>sztejkat.abstractfmt.txt.ATxtReadFormat0</code>
      do apply, so exact type matching between JSON and JAVA is not a special concern.
      
      
      <h2>Stream</h2>
      Since the struct format stream is not a part of a named struct the JSON
      representation of it looks like:
      <pre>
      [
      	<i>structs or elementary primitives</i>,....
      ]
      </pre>
     
      
      <h2>Impact of flush()</h2>
      If <code>flush()</code> is called after first element
      was written after begin signal the stream doesn't know yet
      if there is just a single element in structure or there will
      be more. It assumes then that there will be more elements
      and will write it using array form.
      <table caption="Example" border="1">
      <tr> <td>JAVA</td><td>JSON</td></td>
      <tr> <td>
      <pre>
      	begin("ally");
      	writeInt(3);
      	end();
      </pre></td>
      <td>
      <pre>
      {"ally":3}
      </pre>
      </td>
      </tr>
      
      <tr> <td>
      <pre>
      	begin("ally");
      	writeInt(3);
      	flush();
      	end();
      </pre></td>
      <td>
      <pre>
      {"ally":[3]}
      </pre>
      </td>
      </tr>
      
      </table>
      <p>
      If <code>flush()</code> is called between string operations
      or char block operations the current JSON string is terminated
      and subsequent allowed  block operations will start new JSON
      string. This allows a complete token to be delivered to remote
      site.
       <table caption="Example" border="1">
      <tr> <td>JAVA</td><td>JSON</td></td>
      <tr> <td>
      <pre>
      	begin("ally");
      	writeString("Mother of");
      	writeString("satan");
      	end();
      </pre></td>
      <td>
      <pre>
      {"ally":["Mother of satan"]}
      </pre>
      </td>
      </tr>
      
      <tr> <td>
      <pre>
      	begin("ally");
      	writeString("Mother of");
      	flush();
      	writeString("satan");
      	end();
      </pre></td>
      <td>
      <pre>
      {"ally":["Mother of","satan"]}
      </pre>
      </td>
      </tr>      
      </table>
      
      

</body>
</html>
