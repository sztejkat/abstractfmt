<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>sztejkat.abstractfmt</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=UTF-8">
</head>
<body>
	This package defines basic contracts for structured format made around 
	a concept of "signals"

	
	
	
	<h1>Definitions</h1>
	<h2>Cursor</h2>
	A location in a stream from which next data will be read.
	<p>
	In generic implementing a stream may involve some "read-ahead" or
	"unreading" but from the user API point of view cursor always moves
	only forward.
	
	
	
	
	<h2 id="PRIMITIVE_DATA">Primitive data</h2>
	Any data which is reflecting native JAVA data types,
	including <code>String</code> and arrays and excluding references.
	<p>
	Primitive data are divided in two categories:
	<ul>
		<li><a href="#ELEMENTARY_PRIMITIVE">elementary primitives</a>;</li>
		<li><a href="#PRIMITIVE_SEQUENCES">primitive sequences</a>;</li>
	</ul>
	The stream format carries <u>no information</u> about what type of
	primitive is stored where. 
	<p id="MISSERABLE_FAULT">
	It is allowed however to <u>fail misserably</u>	if type of primitive which is found in stream is different from the type 
	expected by the reading code. This failure is allowed to be delayed	and corrupt reading of all other primitive 
	data <u>up to the nearest <a href="#SIGNAL">signal</a></u>. Reaching the signal <u>must be correct</u> and
	<u>must correct</u>	that faulty condition. Reading of the data after the signal must be unaffected by a previous mistake.
	<p>
	This correction must take place always and unconditionally,
	even if signal happens to appear in the middle of primitive data.
	
	
	
	
	
	
	 
	<h2 id="SIGNAL">Signal</h2>
	A unique sequence of bits (or other entities) in stream which can
	be always correctly idenitified regardless of the position of a cursor
	inside any portion of primitive data.
	<p>
	The signal must have such a property that:
	<ul>
		<li>it must be always possible to move cursor from one signal to
		another signal;</li>
		<li>it must be always possible to move cursor from inside of primitive
		data to next signal regardless if cursor is at logically correct location or not.
		<p>
		This is explicite reuqired that this operation must be possible 
		even if primitive data were interpreted incorrectly and read with
		incorrect functions or if some primitive data were left not processed yet;</li>		
	</ul>
	See also <a href="#BEGIN">begin signal</a> and <a href="#END">end signal</a>.
	
	
	
	
	<h2 id="BEGIN">Begin signal</h2>
	Begin signal is a signal which is always paired with a <code>String</code>
	representing signal name. This is totally irrelevant how this pairing is achived
	and no assumption is made about the technique.
	<p>
	The name of signal may be an empty string.
	<p>
	The begin signal starts the <a href="#STRUCT">structure</a>.
	<p>
	The implementations are strongly recommended to somehow optimize the storage
	and avoid storing frequently used signal names in full textual. A kind of
	frequently used names registry is recommended.
	
	
	
	
	<h2 id="END">End signal</h2>
	A signal which is having no name and terminates the <a href="#STRUCT">structure</a>.
	
	
	
	
	<h2 id="STRUCTURE">Structure</h2>
	Anything between <a href="#BEGIN">begin signal</a> and <a href="#END">end signal</a>,
	that is any combination of <a href="#PRIMITIVE_DATA">primitive data</a> and structures.
	
	
	
	
	<h2 id="ELEMENTARY_PRIMITIVE">Elementary primitives</h2>
	All primitive JAVA types:
	<pre>
	boolean,byte,char,short,int,long,float,double
	</pre>
	stored in stream as single entities and written or read using dedicated single 
	argument API.
	
	
	<h2 id="PRIMITIVE_SEQUENCES">Primitive sequences</h2>
	All primitive JAVA array types:
	<pre>
	boolean[],byte[],char[],short[],int[],long[],float[],double[],String
	</pre>
	Sequences are stored in stream in a compact form and are always terminated by <a href="#SIGNAL">signal</a>.
	<p>
	This format:
	<ul>
		<li> assumes, that a primitive sequence of type T[] <u>cannot be</u> 
		read using repetitive operation of elementary primitive read of type T;</li>
		<li> requires that there is <u>no size</u> limit of primitive sequence. 	 
		Specifically this format does not store any information about the length of primitive
		sequence except of terminating it with a <a href="#SIGNAL">signal</a>;</li>
		<li> requires that a single continous sequence T[] <u>may be</u> written
		with <u>more that one</u> call to writig API and <u>may</u> be read with <u>any combination</u>
		of calls to sequence T[] reading API;</li>
	</ul>
	<p>
	The side effects of those requirements are:
	<ul>
		<li>Once primitive sequence operation of type T[] is initialized only that operation
		and signal operations can be used. All other operations are prohibitted and
		must throw <code>IllegalStateException</code>;</li>
		<li>One can't write two sequences, either same type or another, without injecting
		a signal between them. Especially this structure:
		<pre>
			struct{
					int 
					int 
					double []
					long []
					int
					}
		</pre>
		must be written as:
		<pre>
			<i>begin signal</i>
					elementary int
					elementary int
					<i>begin signal</i>
					sequence double []
					<i>end signal</i>
					<i>begin signal</i>
					sequence long []
					<i>end signal</i>
					elementary int
			<i>end signal</i>
		</pre>
		However the structure:
		<pre>
			struct{
					int 
					int 
					double []
					}
		</pre>
		<u>can</u> be written as:
		<pre>
			<i>begin signal</i>
					elementary int
					elementary int
					sequence double []
			<i>end signal</i>
		</pre>
		This is intentional.
		</li>
	</ul>
		
	
	
	
	
	
	
	
	<h1>Operations on stream</h1>
	This chapter defines elementary operations on streams.
	
	<h2>Writing a stream</h2>
	The writing of stream is performed using following operations:
	<ul>
		<li>writing signals;</li>
		<li>writing elementary primitives;</li>
		<li>writing primitive sequences;</li>
	</ul>
	
	<h3>Writing singals</h3>
	 <h4>Writing the "begin signal"</h4>
	   Writing begin signal can happen in any place and always takes signal 
	   name as an agrument. How that name is encoded in stream is not a concern
	   of this api.
	   <p>
	   The format:
	   <ul>
	   	<li>requires, that there is no hard, conceptually built-in limitation
	   	   on the length of a signal name;</li>
	   	<li>requires,  that there is no hard, conceptually built-in limitation
	   	   on the depths of structures recursion;</li>
	   	<li>requires,  that there is noÂ limitation on what characters can be contained
	   	    in name, including <code>(char)0</code> and names are stored as supplied, without
	   	    any upper/lower case handling nor normalization of any kind. Especially the 
	   	    "" (empty) name is allowed. However <code>null</code> reference does not 
	   	    describe a valid name and is not the same as "" (empty);</li>
	   	<li>requires, that formats must contain an adjustable function which
	   	    will prevent it from reading and writing too long names;</li>
	   	<li>requires, that formats must contain an adjustable function which
	   	    will prevent it from reading and writing too deeply recursed structures;</li>
	   	<li>requires, that formats which do contain some hard-coded, built in limits
	   	    for names or recursion must report them to user through well defined API;</li>
	   </ul>
	   Additionally this format recommends that:
	   <ul>
	   	 <li>The way of encoding signals should be as compact as possible;</li>
	   	 <li>The format should allow at least 17 signal names to be pre-defined as
	   	 to be used in a most compact possible form. That number of names matches the
	   	 number of primitive types and is intended to be used in <i>typed streams</i>
	   	 to wrap all primitives and allow to detect the <a href="#MISSERABLE_FAULT">misserable fault</a>
	   	 at incorrectly typed read;</li>
	   </ul>
	   
	 <h4>Writing the "end signal"</h4>
	   Writing an end signal is allowed only inside an existing structure.
	   The number of begin and end signals must be balanced.
	   <p>
	   Writing API takes no argument.
	   
	<h3>Writing elementary primitive</h3>
	   Writing an elementary primitive is allowed in any place, except if
	   primitive sequence write was initialized.
	   <p>
	   This format especially allows to write primitives outside any structure
	   (that is without any unclosed begin signal present).
	   <p>
	   There is no requirement that any kind of type information is to be
	   stored, however signal names can be used to provide that kind of information.
	   <p>
	   Writing API takes exactly one argument.
	   
	<h3>Writing primitive sequences</h3>
	   Writing of primitive sequence is allowed in any place, except if
	   primitive sequence write of an another type was initialized.
	   <p>
	   First write of primitive sequence of type T initializes the primitive
	   sequence in stream and since that moment only allowed subsequent
	   writes are signals and sequence of the same type.
	   <p>
	   Writing any signal terminates the sequence.
	   <p>
	   Writing API takes as an argument single element, array of elements
	   or <code>String</code>.
	   <p>
	   The format assumes, that sequence <code>char[]</code> is <u>not compatible</u> 
	   with <code>String</code> sequence and their API cannot be used interchangably.
	   <p>
	   <i>Note: This assumption was made with Java classes serialization in mind,
	   where there will be, by convention, plenty of textual information which can
	   be efficiently stored using compact UTF-8 encoding. The <code>char[]</code> is on the other
	   hand reserved for cases when UFT-8 encoding would be not optimal and UTF-16 would be best.</i>   
	   <p>
	   There is no requirement that any kind of type information is to be
	   stored, however signal names can be used to provide that kind of information.
	   
	   
	<h2>Reading stream</h2>
	Reading stream consists of operations:
	<ul>
		<li>elementary primitive reads;</li>
		<li>primitive sequence reads;</li>
		<li>signal reads;</li> 
	</ul>
	
	<h3 id="EOF_HANDLING">End-of-file condition</h3>
	The format requires that a <u>permanent</u> "no more data" condition
	is represented by throwing an <code>IOException</code>.
	<p>
	How the API behaves if there is <u>temporary</u> "no more data" in stream
	it is unspecified and depends on implementation. It may 
	either block awaiting for new data to come, or throw an exception. 
	 
	<p>
	<i>Note: The example of "permanent no more data" is the end of file on
	disk when file is open in an exclusive mode. The example of "temporary no more data"
	is when the network connection fails to supply data in specified time frame because
	the data source has nothing to say at the moment but the connection is still alive.
	</i>
	<p>
	<i>
	The "permanent no more data" 
	cannot be cleared, the "temporary no more data" can be when new data will be present.
	</i> 
	
	<h3>Reading errors handling</h3>
	This format defines, that if stream throws an exception
	then it is up to the <u>user</u> of a stream to ensure that it is no longer used,
	unless the <u>implementation</u> clearly states, that it can be re-tried.
	<p>
	The eventual re-try on failure is <u>implementation dependent</u> and
	the API <u>does assume</u> no retry by default.
	<p>
	The format defines that a re-try on a failed stream which <u>does not</u> support a 
	retrying may <u>fail misserably</u> in an unpredictable way. However a 
	wrapper against such a miss-use will be provided by the API.
	
	<h3>Signal reads</h3>
		A signal read operation API is expected to 
		move cursor from current location up to next 
		signal in stream, read that signal, move cursor
		past it and return the signal to user.
		<p>
		When begin signal is encountered API returns signal
		name. When end signal is encountered API returns <code>null</code>.
		
	<h3>Primitive read, in generic</h3>	
		Reading starts at current cursor location and moves cursor step-by-steam as it is reading
		parts of primitive element (ie. bytes in binary format or chars in text format)
		until all parts are read <u>or a signal is reached.</u>
		<p>
		The cursor can't be moved past the signal with any elementary read. It just stops
		there until signal is read.
		<p>
		This is not expected that format validates if read API of correct type is used,
		except if wrapped in <i>typed stream</i>.
		<p>
		Read is allowed to fail misserably and break all subsequent readings,
		as described in <a href="#ELEMENTARY_PRIMITIVE">there</a> if type does not
		match.
		<p>
		A read which starts at the signal fails with an indicator
		that there is "no more data in structure". 
		This condition can be cleared only by reading a signal.
		<p>
		A read which makes an attempt to crross the signal inside an element
		fails with an indicator	that there is "signal is crossed". 
		This condition can be cleared only by reading a signal and is always 
		indicated by throwing a dedicated exception.
		
	<h3>Elementary primitive read</h3>
		This read may happen in any place except if sequence read is active.
		<p>
		Elementary read API takes no argument and returns single value.
		<p>
		Elementary read indicates "no more data in structure" by throwing a dedicated exception.
		
	<h3>Primitive sequence read</h3>
		This read may happen in any place except if sequence read of different type is active.
		<p>
  	    First read of primitive sequence of type T[] initializes the primitive
	    sequence in stream and since that moment only allowed subsequent
	    read are reading signals and sequence of the same type.
	    <p>
	    Sequence read to check for "no more data in structure" at each fetched
	    element of sequence. The "signal is crossed" is checked during fetching 
	    each element of a sequence. 
	    <p>
	    Sequence reads do indicate "no more data in structure" by returning
	    with "partial read condition" indicating this way, that a correctly
	    marked end of sequence was reached. 
	    <p>
		The reading API takes <u>a buffer of bound size</u> and returns information how much of it was filled up.
		There is <u>no unbound</u> operations. 
		<p>
		The "partial read" condition is represented by returning the number of
		read elements lower than the size of supplied buffer.
		<p>
		This API requires that "partial read" returning zero inidicates that nothing
		could be read due to a "temporary lack of data" and -1 indicating that nothing
		could be read due to reaching a signal.
		<p> 
		A permanent lack of data is handled as specified <a href="EOF_HANDLING">there</a>. 		
		<p>
		The sequence readinhg API provides buffer-less, single element fetching API which 
		do indicate "partial read" by throwing the same exception as an elementary primitive
		read would do on "no more data in structure".
		
	  
		
		
		
		
		
		
		
		
	<h1>Extensions</h1>
	This chapter describes functional extensions implemented <u>over</u> the basic structured stream.
	<h2>Fail-safe wrappers</h2>
	A wrapper which catches any IOException except <code>ENoMoreData</code> used to indicate
	an attempt to cross signal boundary in an allowed way. 
	<h2>Typed stream</h2>
	The stream which encloses each primitive operation withing own named structure where the name describes a type of
	primitive.
	<p>
	This stream reserves some names as "type information". If user writes the signal of conflicting name this name is
	transparently escaped and un-escaped after read.
	<p>
	All API behaves the same way as usuall and type information is hidden from a user, except the condition when incorrect
	primitive operation is required. If this happens an exception is thrown.
	<p>
	The API is extended with "nextType" information which using read reserved signals informs user what type is at the cursor
	in the stream. This API allows blind transcoding of streams of unknown structures. 
</body>
</html>
