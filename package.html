<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>sztejkat.abstractfmt</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=UTF-8">
</head>
<body>
	This package defines basic contracts for signal/event based data format.

	<h1>Definitions</h1>
	<h2>Event base format</h1>
	The data stream expressed in a form of an event based format consists 
	of a sequence of possibly nested <a href="#event"><i>events</i></a>
	interlaved with a non-interruptible 
	sequence of <a href="#primitives"><i>primitive data</i></a>
	<p>
	This is a three tire format.
	<h3>Three tire format</h3>
	<p>
	First tire are <a href="#event">"events"</a> and their primiary task is to identify
	and arrange data by giving them some <i>names</i>.
	<p>
	Second tire are <a href="#signals">"signals"</a> which are used to detect events boundaries.
	This is a tire at which public API in this package is defined. 
	Check <a href="ISignalReadFormat.html">ISignalReadFormat</a> and <a href="ISignalWriteFormat.html">ISignalWriteFormat</a>
	for details.
	<p>
	And a last tire is made of <a href="#indicators">"indicators"</a> which are used
	to indicate where signals, names and primitives are located and in what form they are
	described. This last tire is used as a possible back-end for upper level tires,
	but does not have to be. Check <a href="IIndicatorReadFormat.html">IIndicatorReadFormat</a>
	and <a href="IIndicatorWriteFormat.html">IIndicatorWriteFormat</a>.
	
	
	<h1>Properties of an event based format</h1>
	<ul>
		<li>the set of operations necessary to write data is bound, known and simple;</li>
		<li>operations which may benefit from a specific data packing are defined 
		as <a href="#block"><i>block</i></a> operations;</li>
		<li>the format does not know anything about objects, references and etc;</li>
		<li>any binary or textual representation can be used, providing there is a proper back-end;</li>
	</ul>
	Additionally the <a href="#fullydescribed"><i>described format</i></a> allows:
	<ul>
		<li>strong, type based validation;</li>
		<li>format transcoding without the need of any additional knowledge about what data are contained in stream;</li>
	</ul>
	
	
	
	<h1>Standards used in this package and sub-packages</h1>
	<h2>Exceptions</h2>
	In generic <code>AssertionError</code> is thrown by <code>assert</code> and is a required
	minimum of defense against coder errors. The implementations are allowed to
	use strictier, always enabled error testing and may throw any subclass of 
	<code>RuntimeException</code>.
	
	
	
	<hr></hr>
	<a name="event"><h1>Events</h1></a>
	An <a href="#event"><i>event</i></a> is a <i>named</i> block of possibly nested events
	interlaved with a non-interruptible sequence of <a href="#primitives"><i>primitive data</i></a>.
	<p>
	A beginning of an event is indicated by <a href="#begin"><i>begin signal</i></a> and an end of
	an event is indicated by <a href="#end"><i>end signal</i></a>.
	
	
	
	<a name="signal"><h1>Signals</h1></a>
	By <a href="#signal"><i>signal</i></a> we do understand some means used to indicate beginning and
	an end of an <a href="#event"><i>event</i></a>.
	<p>
	This is requied that a mechanism used for storig signals must be designed in such way,
	that there must be a possibility to	iterate through the stream from signal to signal 
	without the need of understanding anything of a stream content between signals.
	
	<a name="begin"><h3>Begin signal</h3></a>
	A named <a href="#signal"><i>signal</i></a> which is carying a <a href="#name"><i>name</i></a>
	and indicates the start of an <a href="#event"><i>event</i></a>.
	
	<a name="name"><h4>Name of signal</h4></a>
	A text made of of full Java <tt>char</tt> characters space with no charset nor size restriction,
	represented in API as <Tt>String</tt> object.
	<p>
	A formats are recommended to use as compact as possible mapping from <tt>String</tt> event representation
	to internal one stored in a stream. The recommended policy is to assign a number to first (limited in count by size
	of that number) few signals, store this information in stream and use assigned numbers later instead of full,
	textual form. Notice, this policy must
	not restrict the total number of supported signals. If more different signals is
	to be written to a stream then the stream must write them directly,
	in full textual form, without any mapping.
	<p>
	This mapping is not visible through API and handled transparently by formats.
	<p>
	The formats may limit the length of signal name to defend against "out-of-memory" attacks
	but the limit may not be smaller than 8 characters and must be directly reported through API.
	
	
	<h4>Decodnig signals and acting according to the names</h4>
	
	In plenty of use scenarios stream readers will have to react on names of incomming signals.
	If there is a signal X do one thing, if there is a signal Y do the other thing.
	<p>
	This package have chosen signal names to be strings rather than numbers
	because this do let us to be less prone to <i>name clash</i> if different pieces
	of code are written by different persons, projects or teams.
	<p>
	The price for using strings is a less efficient comparison.
	<p>
	Since JDK 7 there is the <code>switch(String)</code> is using <u>cached hash code</u>:
	<pre>
		switch(<i>some string</i>)
		{
			case "one":
			case "two":...
		};
	</pre>
	which is NOT implemented as:
        <pre>
             if ("one".equals(x))
             {
             }else
             if ("two".equals(x))
             {
             }...
        </pre>
        Instead it is implemented, roughly speaking, as:
        <pre>
                static final int ONE = "one".hashCode();   //thanks to cast in stone JLS implementation of hashCode()
                static final int TWO = "two".hashCode();
                ...
                switch(x.hashCode)
                {
                    case ONE:     // grouping all identical hash codes at compile time
                    case TWO:
                           if ("one".equals(....))
                };
        </pre>
        This is quite efficient when there is a large switch statement
        over short strings. The primary cost comes from the need of
        computing hashCode which takes ages for very, very long strings.
        Second cost comes from the possibility that all <code>case:</code> hash codes
        will be the same. And at last, from the fact, that at least one <code>String.equals(...)</code>
        will have to be executed.
        <p>
        If this performance is not good for You may restrict Your names length
        and still keep them somehow human readable. For an example
        if You will restrict recognized names to up to 4 ASCII letters,
        where each ASCII is 0...255 number You may easily transform
        the string to 1:1 identity mapped integer:
        <pre>
             int v = (char[0] & 0xff)+((char[1] & 0xff)&lt;&lt;8)...
        </pre>
        and use the <code>v</code> in <code>switch</code> statement
        directly. With restriction to only capital letters (without numbers you have 26
        ASCII letters) you may use only 5 bits per letter, so you can have
        six letters long unique names identity mapped to single integer.
        <p>
        And finally You may make a use from a fact, that even tough names <u>are</u>
        strings, they do <u>not have to be human readable</u>. A single character long
        string may be good enough for You if You just use it as a number like:
        <pre>
             if (x.length()==1)
             {
              switch(x.charAt(0))
              {
               case 0x0909:
               case 0xFFAA:
              };
             };
        </pre>
        which is a fastest possible solution.
	
	
	<a name="end"><h3>End signal</h3></a>
	A plain signal, without a name, which indicates the end of a last event. This is an error when
	<a href="#end"><i>end signal</i></a> appears without a matching <a href="#begin"><i>begin signal</i></a>.
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	<a name="primitives"><h1>Primitive data</h1></a>
	<p>
	<i>Note: This part is JAVA specific.</i>
	<p>
	A sequence of <a href="#elementary"><i>elementary primitives</i></a>
	and  <a href="#block"><i>block operations</i></a>.
	Those operations are <a href="#uninterruptible"><i>un-interruptible</i></a>.
	
	<a name="elementary"><h3>An elementary primitive</h3></a>
	Elementary primitive data consists of sequences of data representing following Java data types:
	<ul>
			<li>boolean</li>
			<li>byte</li>
			<li>char</li>
			<li>short</li>
			<li>int</li>
			<li>long</li>
			<li>float</li>
			<li>double</li>
	</ul>
	
	<a name="block"><h3>A block operation</h3></a>
	A block operation is a continous sequence of data taken from following Java types:
	<ul>
			<li>boolean[]</li>
			<li>byte[]</li>
			<li>char[]</li>
			<li>short[]</li>
			<li>int[]</li>
			<li>long[]</li>
			<li>float[]</li>
			<li>double[]</li>
	</ul>
	A block operation terminates with an <a href="#end"><i>end signal</i></a> 
	of an enclosing	<a href="#event"><i>event</i></a> or with <a href="#begin">begin signal</a> of next event.
	<p>
	Of them <code>byte[],char[]</code> are <i>primary</i> block operations which
	should be always implemented in as compact way as possible.
	<p>
	<i>This is because if You start playing with it, You will notice, that
	in many cases You will use <code>byte[]</code> to store raw data (aka <code>InputStream/OutputStream</code>)
	and <code>char[]</code> to preserve class names, structure names and etc, which are usually
	ASCII.</i>
	
	
	<h4>Difference between <code>byte[]</code> and <code>byte,byte,...</code></h4>
	This package assumes, that when user writes data using sequnce of elementary primitives,
	user is focused on preserving it's readability to humans, give them names and etc.
	<p>
	On the contrary, if user is using block operation, he/se is suggesting that each element
	in block has less of importance and that this is important, that whole block is properly
	named, indentified, described and etc.
	<p>
	See also <a href="doc-files/block-operations.html">this document for some discussion.</a>
	<p>
	
	
	<a name="uninterruptible"><h3>Un-interruptible primitives</h3></a>
	Each primitive operation is <i>un-interruptible</i> what means, that stream format requires that
	primitive written with operation of type X must be read by an operation of the same type. This has a side
	effect which prevents from fetching "long" by a sequence of "byte" fetches and etc.
	<p>
	For block operation  <i>un-interruptible</i> means additionally, that one cannot mix block operations
	of different types nor introduce a non-block operation until the next <a href="#begin"><i>begin signal</i></a> 
	or <a href="#end"><i>end signal</i></a>.
	<p>
	The format reaction on breaking this rule are different for <a href="#fullydescribed"><i>fully described</i></a>
	formats and <a href="#nondescribed"><i>non-described</i></a> formats.
	
	<a name="nondescribed"><h2>Non described format</h2></a>
	A non-described format is bound, in addition to stated generic requirements, to ensure that:
	<ul>
			<li>regardless of in what state it is, there is always a possibility to move to next signal
			skipping the un-processed content without any complaints. This should be true
			also if primitives are read with incorrect methods;</li>
			<li>to ensure that if any <i>primitive operation</i> attempts to initiate a read when there is no data 
			due to presence of a <a href="#signal"><i>signal</i></a> the <a href="ENoMoreData.html">ENoMoreData</a>
			exception is thrown;</li>
			<li>to ensure that if any primitive operation encounters end-of-stream condition
			the <a href="EUnexpectedEof.html">EUnexpectedEof</a> exception is thrown;</li>
			<li>to ensure that once block operation initiated only block operation of same type is allowed till next signal;</li>			
	</ul>
	<i>Note: The effect of encountering signal inside a primitive element body is unspecified.</i>
	
	<a name="fullydescribed"><h2>Described formats</h2></a>
	Fully described format extends functionality of <a href="#nondescribed"><i>non-described format</i></a> and
	is bound to use means which can ensure that:
	<ul>
		<li>an attempt to read primitive data with method non matching type in stream (breaking the interruptibility)
		results in <a href="EDataMissmatch.html">EDataMissmatch</a> exception;</li>
		<li>user may ask stream format, while reading, if next stream content is a <a href="#signal"><i>signal</i></a> or
		a <a href="#primititves"><i>primitive</i></a> and may get information what primitive type is is;</li>
	</ul>
	
	
	
	
	
	
	
	
	
	<hr></hr>
	<h1 id="indicators">Indicators</h1>
	Indicators are third-tier API and usually will be part of implementation and will not
	be used by users directly. If You are however going to implement own back-end format,
	then the easiest way will be to make it by providing Your own implementation of
	indicators.
	<p>
	<i>See <a href="IIndicatorReadFormat.html">IIndicatorReadFormat</a> and 
	<a href="IIndicatorWriteFormat.html">IIndicatorWriteFormat</a>.</i>
	<p>
	Indicators are used to compose signals and tell about primitives.
	<p>
	An "indictator" must have following properties:
	<ul>
		<li>stream should be always able to tell apart data from indicator;</li>
		<li>stream should be always able to look for an indicator;</li>
		<li>stream should be always able to check if and what indicator is under cursor;</li> 
	</ul>
	For an informat discussions see <a href="doc-files/escapes-chunks-and-signals.html">this document</a>.
	
	<h2>Indicators used to build signals</h2>
	The begin signal is built with following indicators:
	<ul>
	<li>if names are encoded directly, without any re-use optimization:
	<pre>
		begin-indicator <i>or</i> end-begin-indicator
		direct-indicator
		<i>signal-name-data</i>
	</pre>
	</li>
	<li>if names are encoded with re-use optimization and name is used for a first time
	<pre>
		begin-indicator <i>or</i> end-begin-indicator
		register-indicator (with re-use identifier)
		<i>signal-name-data</i>
	</pre>
	</li>
	<li>if names are encoded with re-use optimization and name is reused
	<pre>
		begin-indicator <i>or</i> end-begin-indicator
		register-use (with re-use identifier)
	</pre>
	</li>
	</ul>
	The end signal is built with following indicators:
	<ul>
	<li>if there is no end-followed-by-begin optimization:
	<pre>
		end-indicator
	</pre>
	</li>
	<li>if there is end-followed-by-begin optimization AND there is begin signal afterwards
	<pre>
		end-begin-indicator <i>which is a part of begin signal</i>
	</pre>
	</li>
	</ul>
	
	<h2>Indicators used to provide information about primitives</h2>
	Indicators can be also use to provide informations about
	primitives if format is <a href="fullydescribed">described.</a>
	<p>
	Following indicators are used in following sequence.
	<pre>
		type-indicator <i>separate for each elementary and array primitive</i>
		<i>actual primitive data</i>
		flush-type-indicator <i>separate for each elementary and array primitive</i>
	</pre>
	<p>
	<i>Note: flush-type-indicator indicator is optional. Can be type specific, class generic (elementary/block),
	generic or not present at all.</i>
	<p>
	<i>Note: flush-type-indicator indicator is introduced to API because of some formats which require to
	surround data with proper, matched indicators. Signal streams are using it, but indicator formats may
	ignore them if not used in their specific context.</i>
	<p>
	
	
	
	

</body>
</html>
