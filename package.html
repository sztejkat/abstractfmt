<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>sztejkat.abstractfmt</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=UTF-8">
</head>
<body>
	This package defines basic contracts for structured format made around 
	a concept of "signals"

	
	
	
	<h1>Definitions</h1>
	<h2>Cursor</h2>
	A location in a stream from which next data will be read.
	<p>
	In generic implementing a stream may involve some "read-ahead" or
	"unreading" but from the user API point of view cursor always moves
	only forward.
	
	
	
	
	<h2 id="PRIMITIVE_DATA">Primitive data</h2>
	Any data which is reflecting native JAVA data types,
	including <code>String</code> and arrays and excluding references.
	<p>
	Primitive data are divided in two categories:
	<ul>
		<li><a href="#ELEMENTARY_PRIMITIVE">elementary primitives</a>;</li>
		<li><a href="#PRIMITIVE_SEQUENCES">primitive sequences</a>;</li>
	</ul>
	The stream format carries <u>no information</u> about what type of
	primitive is stored where. 
	<p>
	It is allowed however to <u>fail misserably</u>	if type of primitive is found in stream is different from the type 
	expected by the reading code. This failure is allowed to be delayed	and corrupt reading of all other primitive 
	data up to the nearest <a href="#SIGNAL">signal</a>. Reaching the signal <u>must correct</u>
	that faulty condition and reading of data after the signal must be unaffected by previous mistake.
	This correction must take place even if signal happens to appear in the middle of primitive data.
	
	
	
	
	
	
	 
	<h2 id="SIGNAL">Signal</h2>
	A unique sequence of bits (or other entities) in stream which can
	be always correctly idenitified regardless of the position of a cursor
	inside any portion of primitive data.
	<p>
	The signal must have such a property that:
	<ul>
		<li>it must be always possible to move cursor from one signal to
		another signal;</li>
		<li>it must be always possible to move cursor from inside of primitive
		data to next signal regardless if cursor is at logically correct location or not.
		<p>
		This is explicite reuqired that this operation must be possible 
		even if primitive data were interpreted incorrectly and read with
		incorrect functions or if some primitive data were left not processed yet;</li>		
	</ul>
	See also <a href="#BEGIN">begin signal</a> and <a href="#END">end signal</a>.
	
	
	
	
	<h2 id="BEGIN">Begin signal</h2>
	Begin signal is a signal which is always paired with a <code>String</code>
	representing signal name. This is totally irrelevant how this pairing is achived
	and no assumption is made about the technique.
	<p>
	The name of signal may be an empty string.
	<p>
	The begin signal starts the <a href="#STRUCT">structure</a>.
	<p>
	The implementations are strongly recommended to somehow optimize the storage
	and avoid storing frequently used signal names in full textual. A kind of
	frequently used names registry is recommended.
	
	
	
	
	<h2 id="END">End signal</h2>
	A signal which is having no name and terminates the <a href="#STRUCT">structure</a>.
	
	
	
	
	<h2 id="STRUCTURE">Structure</h2>
	Anything between <a href="#BEGIN">begin signal</a> and <a href="#END">end signal</a>,
	that is any combination of <a href="#PRIMITIVE_DATA">primitive data</a> and structures.
	
	
	
	
	<h2 id="ELEMENTARY_PRIMITIVE">Elementary primitives</h2>
	All primitive JAVA types:
	<pre>
	boolean,byte,char,short,int,long,float,double
	</pre>
	stored in stream as single entities and written or read using dedicated single 
	argument API.
	
	
	<h2 id="PRIMITIVE_SEQUENCES">Primitive sequences</h2>
	All primitive JAVA array types:
	<pre>
	boolean[],byte[],char[],short[],int[],long[],float[],double[]
	</pre>
	and JAVA <code>String</code> stored in stream in a compact form terminated
	by <a href="#SIGNAL">signal</a>.
	<p>
	This format assumes, that a primitive sequence of type T cannot be 
	read using repetitive operation of elementary primitive read of type T.
	<p>
	This format requires that there is no size limit of primitive sequence.
	<p>
	This format does not store any information about the length of primitive
	sequence except of terminating it with a <a href="#SIGNAL">signal</a>.
	<p>
	This format requires that a single continous sequence may be written
	with more that one call to writig API and may be read with any combination
	of calls to sequence reading API.
	<p>
	Once primitive sequence operation of type T is initialized only that operation
	and signal operations can be used. All other operations are prohibitted and
	must throw <code>IllegalStateException</code>.
	
	
	
	
	
	
	
	<h1>Operations on stream</h1>
	This chapter defines elementary operations on streams.
	
	<h2>Writing a stream</h2>
	The writing of stream is performed using following operations:
	<ul>
		<li>writing signals;</li>
		<li>writing elementary primitives;</li>
		<li>writing primitive sequneces;</li>
	</ul>
	
	<h3>Writing singals</h3>
	 <h4>Writing begin signal</h4>
	   Writing begin signal can happen in any place and always takes signal 
	   name as an agrument. How name is encoded in stream is not a concern
	   of this api.
	   <p>
	   There must be no uncessary limitation on how deep signal recursion
	   can be, some implementations may however put such a restriction due to
	   the need of using some kind of memory structure to trace the 
	   depth of stream structure. If such limitation is present it should
	   be adjustable by a user in a format specific API and must be strictly
	   enforced. There is absolutely prohibited to rely on "out of memory"
	   condition.
	 <h4>Writing end signal</h4>
	   Writing an end signal is allowed only inside an existing structure,
	   that is the number of begin and end signals must be balanced.
	   <p>
	   Writing API takes no argument.
	   
	<h3>Writing elementary primitive</h3>
	   Writing an elementary primitive is allowed in any place, except if
	   primitive sequence write was initialized.
	   <p>
	   This format especially allows to write primitives outside any structure
	   (that is without any unclosed begin signal present).
	   <p>
	   There is no requirement that any kind of type information is to be
	   stored.
	   <p>
	   Writing API takes exactly one argument.
	   
	<h3>Writing primitive sequences</h3>
	   Writing of primitive sequence is allowed in any place, except if
	   primitive sequence write of an another type was initialized.
	   <p>
	   First write of primitive sequence of type T initializes the primitive
	   sequence in stream and since that moment only allowed subsequent
	   writes are signals and sequence of the same type.
	   <p>
	   Writing any signal terminates the sequence.
	   <p>
	   Writing API takes as an argument single element, array of elements
	   or <code>String</code>.
	   <p>
	   The sequence of <code>char[]</code> is <u>not compatible</u> 
	   with sequence of <code>String</code>.  
	   
	   
	   
	<h2>Reading stream</h2>
	Reading stream consists of operations:
	<ul>
		<li>elementary primitive reads;</li>
		<li>primitive sequence reads;</li>
		<li>signal reads;</li> 
	</ul>
	The format requires that a <u>permanent</u> "no more data" condition
	is represented by throwing and IOException.
	<p>
	How the API behaves if there is temporary no more data in stream
	it is unspecified and depends on implementation. It may 
	be either blocking or throwing an exception. If however and
	exception is throw and implementation is such, that this exception
	is recoverable (that is one can re-try an operation and stream is
	still usable) the IOException of recoverable (ie. <code>ERecoverableIOException</code>)
	 subclass should be thrown.
	<p>
	API should consider all exceptions not inherited from
	recoverable as non-recoverable failures and stream as non usable.
	<p>
	This format requires, that if stream throws an unrecoverable exception
	then all subsequent calls to all methods should throw <code>IOException</code>
	indicating its permanently faulty state.
	
	
	<h3>Signal reads</h3>
		A signal read operation API is expected to 
		move cursor from current location up to next 
		signal in stream, read that signal, move cursor
		past it and return the signal to user.
		<p>
		When begin signal is encountered API returns signal
		name. When end signal is encountered API returns null.
	
	<h3>Elementary primitive read</h3>
		This read may happen in any place except if sequence read is active.
		<p>
		Read starts at current cursor location and moves cursor as it reads
		parts of data until all parts are read or a signal is reached.
		The cursor can't be moved past the signal with this read.
		<p>
		This is not expected that stream validates if correct elementary read is
		used to read stored type.
		<p>
		This is allowed to fail misserably and break all subsequent readings,
		as described in <a href="#ELEMENTARY_PRIMITIVE">there</a> if type does not
		match.
		<p>
		If elementary read finds any signal in a place it expectes part or beginnig
		of primitive data it should throw an IOException indicating unexpected end of
		structure.
		<p>
		Elementary read API takes no argument and returns single value.
		
	<h3>Primitive sequence read</h3>
		This read may happen in any place except if sequence read of different type is active.
		<p>
  	    First read of primitive sequence of type T initializes the primitive
	    sequence in stream and since that moment only allowed subsequent
	    read are signals and sequence of the same type.
	    <p>
		Read starts at current cursor location and moves cursor as it reads
		parts of data until all parts are read or a signal is reached.
		The cursor can't be moved past the signal with this read.
		<p>
		If sequence read finds any signal where it expectes the beginning of next
		primitive entitiy in sequence it should return "partial read condition".
		If however a signal is found inside a primitive entity it should throw
		and IOException indicating unexpected end of sequence.
		<p>
		The reading API takes a buffer of bound size and returns 
		information how much of it was filled up. 
		<p>
		The "partial read" condition is represented by returning the number of
		entites read lower than the size of supplied buffer.
		<p>
		This API requires that "partial read" returning zero inidicates that nothing
		could be read due to a "temporary lack of data" and -1 indicating that nothing
		could be read due to reaching a signal. A persising lack of data without
		reaching a signal is indicated by throwing an exception of apropriate type.
		<p>
		The <code>byte[]</code> API	also provides argument less API returning <code>int</code> with
		-1 (no more data due to signal), -2 (temporary lack of data) or 0...255 if next byte of sequence is present.
		
	  
		
		
		
		
		
		
		
		
	<h1>Extensions</h1>
	This chapter describes functional extensions implemented <u>over</u> the basic structured stream.
	
	<h2>Typed stream</h2>
	The stream which encloses each primitive operation withing own named structure where the name describes a type of
	primitive.
	<p>
	This stream reserves some names as "type information". If user writes the signal of conflicting name this name is
	transparently escaped and un-escaped after read.
	<p>
	All API behaves the same way as usuall and type information is hidden from a user, except the condition when incorrect
	primitive operation is required. If this happens an exception is thrown.
	<p>
	The API is extended with "nextType" information which using read reserved signals informs user what type is at the cursor
	in the stream. This API allows blind transcoding of streams of unknown structures. 
</body>
</html>
