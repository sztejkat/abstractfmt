------------------------------------------------------------
Designer notes.
------------------------------------------------------------		
..............................
	Contract test suites
..............................
A "test suite" is a set of "test classes" of which each one
is testing subset of abilities of specified contract.
 
In my case I will test contract for ISignalXXXX or IIndicatorXXXX
pairs of formats.

Since each test class is tesing a device under-test based on
certain contract they, obviously, must be provided with a certain "factory"
which will produce instances of contract to test.

Effectively I need a work flow which will allow me:
 - to set a "factory"
 - to run all tests in all test classes of the "suite" with an instance
 of that factory.
 
...............................
	Junit 4 limitations
...............................
Junit is basically a set of "runners" which do take a class and 
does:
  for each class.... (**)
	for each @Test method in class	
		create new instance of class (*1)
		run method.
 
Junit provides us with two so called "runners":
 -Parameterized, which allows to pass arguments to (*1)
 -Suite, which allows us to use (**) loop.

For some unknown reason, even tough Parameterized extends Suite
it does not obey @Suite.SuiteClasses annotation.

So it seems I can either run a set of test classes WITHOUT parameters
or a SINGLE CLASS with parameters.

I can see that there are some open source solutions about it, but I would
rather not like to add more depencencies than necessary.

........................................
	Can I join suites some other way?
........................................
If multiple inheritance would not be a problem, then I could.
But Java, by default, has no multiple inheritance.
At least not at class level.
 
... defaults ....

In JDK 8 there are "Default" interface methods which do provide
a kind of "multiple-inheritance" but Junit 4 does NOT scan 
default methods but only "declared methods".
 
So this path is closed.
 
... extends chain .....

An another solution is to use "extends" chain to 
join tests in cascaded way. C extends B, B extends A and so
on. This way I can have a single test class which can be subclassed
and have a factory provided.
 
I do not like it because this schema does not allow me to
quickly manipulate the test set. For some contracts I may
like to disable some test or select different set to form 
a test suite.

... bundling parameterized tests ....
If each of my "test classes" is parameterized, then
I can bundle them in @Suite.

The problem is, obviously, that parameters for parametrization
has to be produced by static method. And static is not a subject
of easy override.

Even if I point Suite to run inner classes, this inner class
must be static, thous they can reference only static fields
and only fields known at compile time.

........................................
	Can I pass parameters otherwise?
........................................
I may imagine, that when composing a single test class
I will use a kind of:

abstract class Tx
{
	abstrat DUT create()
	
	@Test void x()
	{
		DUT d = create();
		....
	};
};

This is a good, easy and transparent schema.

Now I may compose of them a single test suite with:

@RunWith(Suite.class)
@Suite.SuiteClasses({TS.T1.class})
class TS
{
		public static ... FACTORY
		
	public static class T1 extends Tx
	{
		DUT create(){ return FACTORY.create; };
	};
	
	
};

and create an specific instance of test suite with:

class TSx extends TS
{
	static{
		FACTORY = new....
		}
};

This type of parameters passing should allow me
to pass parameters to tests, but it is not only not very
transparent, but dangeorous. What if two test suites of
different implementations would happen to run in parallel?


........................................
	Joining outside a test suite.
........................................

Now assume, I have a bunch of classes which all do follow
a pattern:

abstract class Tx
{
	abstrat DUT create()
	
	@Test void x()
	{
		DUT d = create();
		....
	};
};
and I have Tx1, Tx2, Tx3 and so on

and I like to merge them into one, compact test suite for
a specific DUT implementation.

@RunWith(Suite.class)
@Suite.SuiteClasses({TSx.T1.class,TSx.T2.class})
class TSx
{ 
	public static final class T1 extends Tx1
	{
		DUT create(){ TSx.create(); };
	};
	public static final class T2 extends Tx2
	{
		DUT create(){ TSx.create(); };
	};
	
	
	static DUT create()
	{
		new ... dut implementation.
	};
};
  

This is relatively easy and transparent job, but is, again
not a suite I would expect, because for each implementation
I must, basically copy this entire setup. Each time I will
add some test class I will need to update ALL test suites.

So this is not what I like best, but it is transparent.

.................................................................
	Reverse, 
.................................................................
Running @RunWith(Parameterized) on a sub-class of 
@RunWith(Suite) does totally override the Suite behavior
and does not run any of suite classes.

.................................................................
	org.junit.experimental.runners.Enclosed
.................................................................
Basically uses inner classes and includes them in tests scan.
Can it use non-static classes?
 
No.

So it does not differ from @Suite.SuiteClasses in practically anything.


.................................................................
	org.junit.runner.JunitCore
.................................................................
This class allows to run tests programatically, but it will surely
break ANT scripting behaviour what is no-go.



-------------------------------------------------------------------------


	Summary


-------------------------------------------------------------------------
One way is to use INHERITANCE to create a test-chain, with a well
known base class and well know end-class. The process of updating
test suite with new test classes will always inject some class
in inheritance chain before the well known end class. With it all
uses of test suite will always receive a full set of tests and each
use is just a sub-class of well known end-class with a factory method
overriden.

An another way is to use @RunWith(Suite) on set of @RunWith(Parameterized)
tests. The suite has a static field which provides parameters to 
Parameterized tests and a sub-class of suite do initialize this field
with inside own static initializer.

First method is a bit messy when it comes to selection of tests,
but will be fool proof in manainance and will correctly survive parallel
tests in multiple threads if used anytime.

Second method is much more flexible on selection, but more troublesome
at mantainance and WILL CRASH on parallel tests in multiple threads
when multiple test suite subclasses will run in parallel. Whether it
will happen or not it is hard to say, but current Junit processing seems
to NOT run different test classes in parallel in the same JVM or
class loader realm.


---------------------------------------------------------------------


	Decision.


---------------------------------------------------------------------

Due to flexibility I decide for COMPOSITOION.



-------------------------------------------------------------------
	Test suite and static initializers.
-------------------------------------------------------------------
There is a real pain in the behind because @RunWith(Suite.class)
applied to class X:

@RunWith(Suite.class)
class public X
{
};

class Y extends X
{	
	static{
		... this code is NOT run
	}
};

When test is told to run class Y tests it will NOT initialize,
for unknown reason, the Y class. It would be easiest for us to
set-up parameters in static initializer.
If however Y has any method annotated with @BeforeClass the static
initializer IS run.




